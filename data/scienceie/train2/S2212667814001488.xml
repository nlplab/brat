<full-text-retrieval-response xmlns="http://www.elsevier.com/xml/svapi/article/dtd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:prism="http://prismstandard.org/namespaces/basic/2.0/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xocs="http://www.elsevier.com/xml/xocs/dtd" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:tb="http://www.elsevier.com/xml/common/table/dtd" xmlns:sb="http://www.elsevier.com/xml/common/struct-bib/dtd" xmlns:sa="http://www.elsevier.com/xml/common/struct-aff/dtd" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:ja="http://www.elsevier.com/xml/ja/dtd" xmlns:ce="http://www.elsevier.com/xml/common/dtd" xmlns:cals="http://www.elsevier.com/xml/common/cals/dtd" xmlns:bk="http://www.elsevier.com/xml/bk/dtd"><coredata><prism:url>http://api.elsevier.com/content/article/pii/S2212667814001488</prism:url><dc:identifier>doi:10.1016/j.ieri.2014.09.100</dc:identifier><eid>1-s2.0-S2212667814001488</eid><prism:doi>10.1016/j.ieri.2014.09.100</prism:doi><pii>S2212-6678(14)00148-8</pii><dc:title>Scripting Language for Java Source Code Recognition </dc:title><prism:publicationName>IERI Procedia</prism:publicationName><prism:aggregationType>Journal</prism:aggregationType><prism:issn>22126678</prism:issn><prism:volume>10</prism:volume><prism:startingPage>119</prism:startingPage><prism:endingPage>130</prism:endingPage><prism:pageRange>119-130</prism:pageRange><dc:format>text/xml</dc:format><prism:coverDate>2014-12-31</prism:coverDate><prism:coverDisplayDate>2014</prism:coverDisplayDate><prism:copyright>Copyright © 2014 The Authors. Published by Elsevier B.V.</prism:copyright><prism:publisher>The Authors. Published by Elsevier B.V.</prism:publisher><prism:issueName>International Conference on Future Information Engineering (FIE 2014)</prism:issueName><dc:creator>Bublík, Tomáš</dc:creator><dc:creator>Virius, Miroslav</dc:creator><dc:description>AbstractThis paper presents general results on the Java source code snippet detection problem. We propose the tool which uses graph and subgraph isomorphism detection. A number of solutions for all of these tasks have been proposed in the literature. However, although that all these solutions are really fast, they compare just the constant static trees. Our solution offers to enter an input sample dynamically with the Scripthon language while preserving an acceptable speed. We used several optimizations to achieve very low number of comparisons during the matching algorithm.</dc:description><openaccess>1</openaccess><openaccessArticle>true</openaccessArticle><openaccessType>Full</openaccessType><openArchiveArticle>false</openArchiveArticle><openaccessSponsorName/><openaccessSponsorType>ElsevierWaived</openaccessSponsorType><openaccessUserLicense>http://creativecommons.org/licenses/by-nc-nd/3.0/</openaccessUserLicense><dcterms:subject>AST</dcterms:subject><dcterms:subject>Java</dcterms:subject><dcterms:subject>tree matching</dcterms:subject><dcterms:subject>Scriphon</dcterms:subject><dcterms:subject>source code recognition</dcterms:subject><link rel="self" href="http://api.elsevier.com/content/article/pii/S2212667814001488"/><link rel="scidir" href="http://www.sciencedirect.com/science/article/pii/S2212667814001488"/></coredata><originalText><xocs:doc xmlns:xoe="http://www.elsevier.com/xml/xoe/dtd" xsi:schemaLocation="http://www.elsevier.com/xml/xocs/dtd http://be-prod3a/schema/dtds/document/fulltext/xcr/xocs-article.xsd"><xocs:meta><xocs:content-family>serial</xocs:content-family><xocs:content-type>JL</xocs:content-type><xocs:cid>282178</xocs:cid><xocs:ssids><xocs:ssid type="alllist">291210</xocs:ssid><xocs:ssid type="subj">291773</xocs:ssid><xocs:ssid type="subj">291800</xocs:ssid><xocs:ssid type="subj">291880</xocs:ssid><xocs:ssid type="subj">291882</xocs:ssid><xocs:ssid type="content">31</xocs:ssid><xocs:ssid type="oa">90</xocs:ssid></xocs:ssids><xocs:srctitle>IERI Procedia</xocs:srctitle><xocs:normalized-srctitle>IERIPROCEDIA</xocs:normalized-srctitle><xocs:orig-load-date yyyymmdd="20141001">2014-10-01</xocs:orig-load-date><xocs:available-online-date yyyymmdd="20141001">2014-10-01</xocs:available-online-date><xocs:ew-transaction-id>2014-10-10T04:56:58</xocs:ew-transaction-id><xocs:eid>1-s2.0-S2212667814001488</xocs:eid><xocs:pii-formatted>S2212-6678(14)00148-8</xocs:pii-formatted><xocs:pii-unformatted>S2212667814001488</xocs:pii-unformatted><xocs:doi>10.1016/j.ieri.2014.09.100</xocs:doi><xocs:item-stage>S300</xocs:item-stage><xocs:item-version-number>S300.2</xocs:item-version-number><xocs:item-weight>HEAD-AND-TAIL</xocs:item-weight><xocs:hub-eid>1-s2.0-S2212667814X00067</xocs:hub-eid><xocs:timestamp yyyymmdd="20150515">2015-05-15T07:34:50.756359-04:00</xocs:timestamp><xocs:dco>0</xocs:dco><xocs:tomb>0</xocs:tomb><xocs:date-search-begin>20140101</xocs:date-search-begin><xocs:date-search-end>20141231</xocs:date-search-end><xocs:year-nav>2014</xocs:year-nav><xocs:indexeddate epoch="1412186304">2014-10-01T17:58:24.856333Z</xocs:indexeddate><xocs:articleinfo>rawtext articleinfo articletitlenorm authfirstinitialnorm authfirstsurnamenorm cid cids confeditor contenttype copyright crossmark dateloaded dateloadedtxt datesearch datesort dateupdated dco docsubtype doctype doi eid ewtransactionid hubeid indexeddate issn issnnorm itemstage itemtransactionid itemweight oauserlicense openaccess openarchive pg pgfirst pglast pii piinorm pubdateend pubdatestart pubdatetxt pubyr sectiontitle sortorder srctitle srctitlenorm srctype ssids alllist content oa subj suppl tomb vol volfirst volissue volumelist webpdf webpdfpagecount yearnav affil articletitle auth authfirstini authfull authkeywords authlast primabst ref</xocs:articleinfo><xocs:issns><xocs:issn-primary-formatted>2212-6678</xocs:issn-primary-formatted><xocs:issn-primary-unformatted>22126678</xocs:issn-primary-unformatted></xocs:issns><xocs:crossmark is-crossmark="1">true</xocs:crossmark><xocs:vol-first>10</xocs:vol-first><xocs:volume-list><xocs:volume>10</xocs:volume></xocs:volume-list><xocs:suppl>C</xocs:suppl><xocs:vol-iss-suppl-text>Volume 10</xocs:vol-iss-suppl-text><xocs:sort-order>19</xocs:sort-order><xocs:first-fp>119</xocs:first-fp><xocs:last-lp>130</xocs:last-lp><xocs:pages><xocs:first-page>119</xocs:first-page><xocs:last-page>130</xocs:last-page></xocs:pages><xocs:cover-date-orig><xocs:start-date>2014</xocs:start-date></xocs:cover-date-orig><xocs:cover-date-text>2014</xocs:cover-date-text><xocs:cover-date-start>2014-01-01</xocs:cover-date-start><xocs:cover-date-end>2014-12-31</xocs:cover-date-end><xocs:cover-date-year>2014</xocs:cover-date-year><xocs:title-editors-groups><xocs:title-editors-group><ce:title>International Conference on Future Information Engineering (FIE 2014)</ce:title><ce:editors><ce:author-group><ce:author><ce:given-name>Garry</ce:given-name><ce:surname>Lee</ce:surname></ce:author></ce:author-group></ce:editors></xocs:title-editors-group></xocs:title-editors-groups><xocs:hub-sec><xocs:hub-sec-title>Computer Engineering</xocs:hub-sec-title></xocs:hub-sec><xocs:document-type>article</xocs:document-type><xocs:document-subtype>fla</xocs:document-subtype><xocs:copyright-line>Copyright © 2014 The Authors. Published by Elsevier B.V.</xocs:copyright-line><xocs:normalized-article-title>SCRIPTINGLANGUAGEFORJAVASOURCECODERECOGNITION</xocs:normalized-article-title><xocs:normalized-first-auth-surname>BUBLIK</xocs:normalized-first-auth-surname><xocs:normalized-first-auth-initial>T</xocs:normalized-first-auth-initial><xocs:references><xocs:ref-info refid="oref0005"/><xocs:ref-info refid="oref0010"/><xocs:ref-info refid="sbref0015"><xocs:ref-normalized-surname>MCKAY</xocs:ref-normalized-surname><xocs:ref-pub-year>1981</xocs:ref-pub-year><xocs:ref-first-fp>45</xocs:ref-first-fp><xocs:ref-last-lp>87</xocs:ref-last-lp><xocs:ref-normalized-initial>B</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0020"><xocs:ref-normalized-surname>ULLMANN</xocs:ref-normalized-surname><xocs:ref-pub-year>1976</xocs:ref-pub-year><xocs:ref-first-fp>31</xocs:ref-first-fp><xocs:ref-last-lp>42</xocs:ref-last-lp><xocs:ref-normalized-initial>J</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0025"><xocs:ref-normalized-surname>LEVI</xocs:ref-normalized-surname><xocs:ref-pub-year>1972</xocs:ref-pub-year><xocs:ref-first-fp>341</xocs:ref-first-fp><xocs:ref-last-lp>354</xocs:ref-last-lp><xocs:ref-normalized-initial>G</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0030"><xocs:ref-normalized-surname>MCGREGOR</xocs:ref-normalized-surname><xocs:ref-pub-year>1982</xocs:ref-pub-year><xocs:ref-first-fp>23</xocs:ref-first-fp><xocs:ref-last-lp>34</xocs:ref-last-lp><xocs:ref-normalized-initial>J</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="oref0035"/><xocs:ref-info refid="sbref0040"><xocs:ref-normalized-surname>BUNKE</xocs:ref-normalized-surname><xocs:ref-pub-year>1998</xocs:ref-pub-year><xocs:ref-first-fp>255</xocs:ref-first-fp><xocs:ref-last-lp>259</xocs:ref-last-lp><xocs:ref-normalized-initial>H</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="oref0045"/><xocs:ref-info refid="oref0050"/><xocs:ref-info refid="sbref0055"><xocs:ref-normalized-surname>SANFELIU</xocs:ref-normalized-surname><xocs:ref-pub-year>1983</xocs:ref-pub-year><xocs:ref-first-fp>353</xocs:ref-first-fp><xocs:ref-last-lp>363</xocs:ref-last-lp><xocs:ref-normalized-initial>A</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0060"><xocs:ref-normalized-surname>TSAI</xocs:ref-normalized-surname><xocs:ref-pub-year>1979</xocs:ref-pub-year><xocs:ref-first-fp>757</xocs:ref-first-fp><xocs:ref-last-lp>768</xocs:ref-last-lp><xocs:ref-normalized-initial>W</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0065"><xocs:ref-normalized-surname>ESHERA</xocs:ref-normalized-surname><xocs:ref-pub-year>1984</xocs:ref-pub-year><xocs:ref-first-fp>398</xocs:ref-first-fp><xocs:ref-last-lp>408</xocs:ref-last-lp><xocs:ref-normalized-initial>M</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="oref0070"/><xocs:ref-info refid="oref0075"/><xocs:ref-info refid="oref0080"/><xocs:ref-info refid="sbref0085"><xocs:ref-normalized-surname>CAELLI</xocs:ref-normalized-surname><xocs:ref-pub-year>2004</xocs:ref-pub-year><xocs:ref-first-fp>329</xocs:ref-first-fp><xocs:ref-last-lp>355</xocs:ref-last-lp><xocs:ref-normalized-initial>T</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="sbref0090"><xocs:ref-normalized-surname>CAELLI</xocs:ref-normalized-surname><xocs:ref-pub-year>2004</xocs:ref-pub-year><xocs:ref-first-fp>515</xocs:ref-first-fp><xocs:ref-last-lp>519</xocs:ref-last-lp><xocs:ref-normalized-initial>T</xocs:ref-normalized-initial></xocs:ref-info><xocs:ref-info refid="oref0095"/><xocs:ref-info refid="oref0100"/><xocs:ref-info refid="oref0105"/><xocs:ref-info refid="oref0110"/><xocs:ref-info refid="oref0115"/><xocs:ref-info refid="oref0120"/><xocs:ref-info refid="oref0125"/></xocs:references><xocs:refkeys><xocs:refkey3>BUBLIKX2014X119</xocs:refkey3><xocs:refkey4lp>BUBLIKX2014X119X130</xocs:refkey4lp><xocs:refkey4ai>BUBLIKX2014X119XT</xocs:refkey4ai><xocs:refkey5>BUBLIKX2014X119X130XT</xocs:refkey5></xocs:refkeys><xocs:open-access><xocs:oa-article-status is-open-access="1" is-open-archive="0">Full</xocs:oa-article-status><xocs:oa-access-effective-date>2014-10-01T11:57:40Z</xocs:oa-access-effective-date><xocs:oa-sponsor><xocs:oa-sponsor-type>ElsevierWaived</xocs:oa-sponsor-type></xocs:oa-sponsor><xocs:oa-user-license>http://creativecommons.org/licenses/by-nc-nd/3.0/</xocs:oa-user-license><xocs:oa-access-inherited-from winid="http://vtw.elsevier.com/content/oaw/PROC_UNBOUNDED_ESWaived">OA-Window</xocs:oa-access-inherited-from></xocs:open-access><xocs:attachment-metadata-doc><xocs:attachment-set-type>item</xocs:attachment-set-type><xocs:pii-formatted>S2212-6678(14)00148-8</xocs:pii-formatted><xocs:pii-unformatted>S2212667814001488</xocs:pii-unformatted><xocs:eid>1-s2.0-S2212667814001488</xocs:eid><xocs:doi>10.1016/j.ieri.2014.09.100</xocs:doi><xocs:cid>282178</xocs:cid><xocs:timestamp>2014-10-10T10:10:04.76193-04:00</xocs:timestamp><xocs:cover-date-start>2014-01-01</xocs:cover-date-start><xocs:cover-date-end>2014-12-31</xocs:cover-date-end><xocs:attachments><xocs:web-pdf><xocs:attachment-eid>1-s2.0-S2212667814001488-main.pdf</xocs:attachment-eid><xocs:ucs-locator>https://s3.amazonaws.com/prod-ucs-content-store-us-east/content/pii:S2212667814001488/MAIN/application/pdf/179ec3e7630b545b8d8ab997a62926af/main.pdf</xocs:ucs-locator><xocs:ucs-locator>https://s3-eu-west-1.amazonaws.com/prod-ucs-content-store-eu-west/content/pii:S2212667814001488/MAIN/application/pdf/179ec3e7630b545b8d8ab997a62926af/main.pdf</xocs:ucs-locator><xocs:filename>main.pdf</xocs:filename><xocs:extension>pdf</xocs:extension><xocs:pdf-optimized>true</xocs:pdf-optimized><xocs:filesize>423615</xocs:filesize><xocs:web-pdf-purpose>MAIN</xocs:web-pdf-purpose><xocs:web-pdf-page-count>12</xocs:web-pdf-page-count><xocs:web-pdf-images><xocs:web-pdf-image><xocs:attachment-eid>1-s2.0-S2212667814001488-main_1.png</xocs:attachment-eid><xocs:ucs-locator>https://s3-eu-west-1.amazonaws.com/prod-ucs-content-store-eu-west/content/pii:S2212667814001488/PREVIEW/image/png/b282521cfbc74beb8511f65d4b3ee61a/main_1.png</xocs:ucs-locator><xocs:ucs-locator>https://s3.amazonaws.com/prod-ucs-content-store-us-east/content/pii:S2212667814001488/PREVIEW/image/png/b282521cfbc74beb8511f65d4b3ee61a/main_1.png</xocs:ucs-locator><xocs:filename>main_1.png</xocs:filename><xocs:extension>png</xocs:extension><xocs:filesize>44601</xocs:filesize><xocs:pixel-height>849</xocs:pixel-height><xocs:pixel-width>656</xocs:pixel-width><xocs:attachment-type>IMAGE-WEB-PDF</xocs:attachment-type><xocs:pdf-page-num>1</xocs:pdf-page-num></xocs:web-pdf-image></xocs:web-pdf-images></xocs:web-pdf></xocs:attachments></xocs:attachment-metadata-doc></xocs:meta><xocs:rawtext> IERI Procedia   10  ( 2014 )  119 â€“ 130  Available online at www.sciencedirect.com 2212-6678  2014 The Authors. Published by Elsevier B.V. This is an open access article under the CC BY-NC-ND license  (http://creativecommons.org/licenses/by-nc-nd/3.0/). Selection and peer review under responsibility of Information Engineering Research Institute doi: 10.1016/j.ieri.2014.09.100  ScienceDirect Fa Abst This graph litera solut We u Â© 20 Sele Keyw 1. I It desc serio work was and * E 20 Scrip culty of Nuclear  ract paper presents  and subgraph ture. However ion offers to en sed several opt 14. Published ction and pee ords: AST; Java ntroduction   is usual tha ribed illnesse us issue. The , serves to pr developed fo its properties Corresponding a -mail address: to 14 Internat ting Lan Sciences and Phy  general result  isomorphism , although tha ter an input sa imizations to a  by Elsevier  r review unde ; tree matching; S t programs,  s start to app re are a lot o ogrammable  r these purpos , can be wri uthor. Tel.: +420 mas.bublik@gm ional Confe guage f TomÃ¡Å¡ B sical Engineerin s on the Java s  detection. A  t all these solu mple dynamic chieve very low B.V. r responsibilit criphon; source  consisting of ear (code du f tools and g Java source c es in the scop tten in this la 605155484.  ail.com.  rence on F or Java  ublÃ­k*, M g Czech Technic Republi ource code sni number of sol tions are reall ally with the S  number of co y of Informat code recognition  a large sou plicity, weak uides on how ode scanning e of this wor nguage. Thi uture Inform Source C iroslav Vi al University in P c ppet detection  utions for all  y fast, they co cripthon langu mparisons duri ion Engineer rce code, are  reusability,   to approach . This tool is b k. A script, w s allows defi ation Eng ode Re rius  rague, Trojanov problem. We p of these tasks  mpare just th age while pres ng the matchin ing Research   becoming c etc.). Mainta  this issue. T ased on the S hich describe ning dynamic ineering  cognitio a 13, Prague, 12 ropose the too have been pro e constant stat erving an acce g algorithm.  Institute  haotic, and  ining a sourc he tool, descr cripthon lang s a source co  properties o n 0 00, Czech  l which uses  posed in the  ic trees. Our  ptable speed.  many times  e code is a  ibed in this  uage which  de structure  f searching   2014 The Authors. Published by Elsevier B.V. This is an open access article under the CC BY-NC-ND license  (http://creativecommons.org/licenses/by-nc-nd/3.0/). Selection and peer review under responsibility of Information Engineering Research Institute 120   TomÃ¡Å¡ BublÃ­k and Miroslav Virius /  IERI Procedia  10 ( 2014 )  119 â€“ 130  requirements. Next, an abstract syntax tree (hereinafter AST) is created dynamically from this script.  Meanwhile, a similar tree is created from given Java source, and these two trees are matched by a graph  matching algorithm. However, not only graph shapes are compared, also trees properties are considered. To  obtain results faster, several graph optimizations are used during this process. And it is possible to scan higher  amount of source code classes during a relatively short time. Typical usage of this approach is as follows: A  user wants to find something, not easily describable, in a large program. But he or she knows that it could be  there. He or she can use our tool and try to find at least the similar snippet of indented code. Therefore, a user  performs a searching procedure, and specifies the input script based on the received results. By repeating this  procedure, he or she filters the unintended results, and finally gets the desired code snippet. Our tool is useful  not just for the fast Java sources scanning, but for example, for a better definability of search conditions.  Another usage area of our tool can be a cloneâ€™s detection problem. By using other clones detection tools, a  material for further research can be gathered. For example, the non-ideal clones are difficult to detect and the  output of such programs isnâ€™t unequivocal in many cases. However, it can be classified by Sripthon, and a  common searching script based on such output  can be.  2. Theory  A graph is an ordered pair à¡³àµŒáˆºà¢‚Ç¡ à¡±áˆ» where à¢‚ is a finite, non-empty set of objects called vertices, and à¡± is  a (possibly empty) set of unordered pairs of distinct vertices i.e., 2-subsets of à¢‚ called edges. The set à¢‚ is  called the vertex set of à¡³, and à¡± is called the edge set of à¡³Ç¤ If à¢‹àµŒáˆ¼à¢›Ç¡ à¢œáˆ½ à¡±×�áˆºà¡³áˆ», we say that vertices à¢› and à¢œ are adjacent in à¡³, and that à¢› à¢™à¢”à¢�à¢•à¢� à¢‹ and à¢œ. Weâ€™ll also say that à¢› and à¢œ are the à¢™à¢Šà¢”à¢‹ of à¢‹. The edge à¢‹ is said  to be à¢šà¢”à¢‹à¢Šà¢�à¢‰à¢”à¢� with à¢› (and à¢œ), and vice versa. We write à¢œà¢› (or à¢›à¢œ) to denote the edge áˆ¼à¢›Ç¡ à¢œáˆ½, on the  understanding that no order is implied. Two graphs are à¢’à¢‡à¢›à¢—à¢‹ if they have the same vertex set and the same  edge set. But there are other ways in which two graphs could be regarded the same. For example, one could  regard two graph as being â€œthe sameâ€� if it is possible to rename the vertices of one and obtain the other. Such  graphs are identical in every respect except for the names of the vertices. In this case, we call the graphs  à¢‰à¢�à¢Žà¢–à¢˜à¢•à¢“à¢•à¢™à¢�. Formally, graphs à¡³ and à¡´ are isomorphic if there is a à«šàµ†à«š correspondence à¢ŒÇ£ à¢‚áˆºà¡³áˆ» Õœà¢‚áˆºà¡´áˆ» such that à¢Ÿà¢ž  ×� à¡±áˆºà¡³áˆ» Õžà¢Œáˆºà¢žáˆ»à¢Œáˆºà¢Ÿáˆ» à¡±×�áˆºà¡´áˆ». This function à¢Œ is called an isomorphism.   A tree is a connected graph that has no cycles (i.e., a connected acyclic graph).   The graph matching problem is actually the same as the problem of finding the isomorphism between the  graphs. Moreover, matching the parts of a graph with a pattern is the same challenge as the finding the  isomorphic subgraph. There are many approaches to this topic in Irniger et al., 2005.  Subgraph isomorphism is useful to find out if a given object is part of another object or even of a collection  of several objects. The maximum common subgraph of two graphs à¢� à«š and à¢� à«›  is the largest graph that is  isomorphic to a subgraph of both à¢� à«š  and à¢� à«› . Maximum common subgraph is useful to measure the similarity  of two objects. Algorithms for graph isomorphism, subgraph isomorphism and maximum common subgraph  detection have been reported in McKay, 1981, Ullmann, 1976, Levi, 1972, McGregor, 1982..  A more general method to measure the similarity of two graphs is graph edit distance. It is a generalization  of string edit distance, also known as Levenshtein distance Stephen 1994.   Another approach measuring the similarity of two graphs is a distance measure based on the maximum  common subgraph between à¢� à«š  and à¢� à«› . With increasing work being done in the field of maximum common  subgraph detection, these measures are growing in popularity. In Bunke et al., 1998, a graph distance measure  based on the maximum common subgraph of two graphs is introduced.   It is shown that the well-known concept of maximum common subgraph distance is a special case of graph  edit distance under particular edit costs. Consequently, algorithms originally developed for maximum  common subgraph detection can be used for edit distance computation and vice versa for the considered edit  121 Tomas Bublik and Miroslav Virius /  IERI Procedia  10 ( 2014 )  119 â€“ 130  costs. Furthermore, in Fernandez et al., 2001 the concepts of maximum common subgraph and minimum  common supergraph are combined to derive a graph distance measure and in Wallis et al., 2001, graph  distances based on the minimum common supergraph denoted as the à¢�à¢˜à¢‡à¢–à¢Ž à¢›à¢”à¢�à¢•à¢” are discussed.  A number of graph matching algorithms are known from the literature Sanfeliu et al., 1983, Tsai et al.,  1979, Eshera et al., 1984, Wong, 1990. All of these methods are guaranteed to find the optimal solution, but  require exponential time and space. Suboptimal or approximate methods, on the other hand, are polynomially  bound in the number of computation steps, but may fail to find the optimal solution.   In Wilson et al., 2004, inexact graph matching is performed by calculating the Levenshtein distance on the  eigenvectors of the graphs. Another approach illustrated in Robles et al., 2005 converts the adjacency matrix  into a string, then uses the leading eigenvector to impose a serial ordering on the string.   Graphs are then matched by applying string matching techniques to their string representation. A different  idea is pursued in Caelli et al., 2004, Caelli et al., 2004 where eigen(sub)space projections and vertex  clustering methods are explored.   Whereas in Caelli et al., 2004 the objective of the method is to work in the eigenspace of the graphs, in  Caelli et al., 2004 subgraphs are matched based on their vertex connectivities defined in the common  subspace.  3. Other Solutions  There exists a lot of searching types which can be used to detect a clone Roy et al., 2009. The textual  approaches belong to basic ones. These approaches are easy to implement, on the other hand, because of a  large excess of non-program material contained in source code, they suffer from a whole range of ailments.  For example, checking a variable scope could be very challenging issue by using textual comparisons.   The token-based comparisons are the next group of approaches needs to be considered. This kind of  approaches divides a source code into the tokens sequences which are compared to each other. This is little  more robust than the textual ones, because it doesnâ€™t work with unnecessary text material like spaces,  comments etc. However, this approach still does not handle a variable or a method scope.  More effective algorithms are the tree-based. There exist two approaches to them: metric-based and tree- based. The metric-based ones use the Java source generated metrics. These metrics are then compared with  the metric generated from original sources. The tree-based methods are base on abstract syntax subtrees  comparison. These methods are used in our work. They are little more difficult to implement, but they are  very effective and they offers more searching options. On contrary, the algorithms based on these methods are  more time consuming comparing to other types.  Ira D. Baxter was a pioneer in this area Baxter et al., 1998. He proposed a solution using the subtrees  hashing into the buckets. And only the same bucket trees are being compared.    Another solution proposed Wahler et al., 2004. He converted AST into XML and applied data mining  techniques on it. The remaining question is the speed of XML processing procedures. Further, an interesting  option proposed Koschke et al., 2006. They serialized generated AST and compared just the suffix tree tokens  of it. The proposed algorithm is very fast. It is able to detect a clone in a linear time.   The lack of these algorithms is the inability to detect snippets dynamically. They suppose a constant and  unchanging original pattern. On the opposite, our solution offers the usage of the dynamic input based on a  scripting language. This means that the input could be conditioned or iterated, and the searching tree changes  according to the searched tree properties. Even the variables can be used. For example, a user can declare the  â€œclazzâ€� variable of type Class, and use it later for the name comparison:   Class clazz  Block(StmtNum=2)  122   TomÃ¡Å¡ BublÃ­k and Miroslav Virius /  IERI Procedia  10 ( 2014 )  119 â€“ 130  if (clazz.Name=="HelloWorld")  ...  else ...  This example means that we search the class with two statements inside, and if the name of this class is  â€œHelloWorldâ€�, then we search something, else we search something else.  4. Scripthon language  Within this work, a new programming language named Scripthon, capable of these functionalities, was  developed. Using this language, it is possible to describe a code structure with properties, and it is even  possible to change the properties of a searching sample in dependence of searched segment properties.  Scripthon is a dynamically typed, interpreted, and non-procedural language. Its translation into a tree- expressing form and its usage is very similar to the usage of any other modern script languages. The complete  definition of the Scripthon language semantics is beyond the scope of this paper, can be found in BublÃ­k et al.  2012.   Because the language is designed to be just a scripting language, there are no special constructions starting  a script. This language is neither a pure object-oriented language. The input for a compiler is a text with a  sequence of commands. This sequence describes consecutive statements in Java source code. Commands with  a variable detail degree correspond to a variable length code segment. A detail level is not fixed, and can vary  in every command. One command can correspond to a line of source code; other one can describe a whole  class in Java. A Scripthon structure is very similar to the structures of the others contemporary dynamic  programming languages. Individual commands are separated by lines. There is no command separator in  Scripthon. Inner parts of blocks are tab nested. A block is not delimited by any signs; just a hierarchy of  tabulators is used.  Looking for a method with a specific name? Suppose we have the most common Java code:  public class HelloWorld {   public static void main(String[] args) {            System.out.println(args);       }  } Letâ€™s suppose we are looking for the method named â€œmainâ€�. Itâ€™s easy. A user just starts a text search dialog  (usually by CTLF + F shortcut) and performs a searching procedure. Unfortunately, this will find a lot of  miscellaneous results. With Scripthon, we can search just methods:  Meth(Name=â€�mainâ€�)   Moreover, we want just the public and static ones:  Meth(Name=â€�mainâ€�; Rest=[public, static])   Even more, the most specific searching criteria for the main method are:  Meth(Name="main"; Rest=[public, static]; Ret=void; ParNum=1; ParTypes=[String[]];  ParNames=["args"])  With Scripthon, we can define a method call inside the main method:  123 Tomas Bublik and Miroslav Virius /  IERI Procedia  10 ( 2014 )  119 â€“ 130  Meth(Name=â€�mainâ€�; Rest=[public, static])    MethCall(Name="System.out.println";Params=["args"])  Scripthon supports also a block of code description. We can define properties of block by this way:    Class(Name="HelloWorld")    Meth(Name=â€�mainâ€�)     Block(StmtNum=1;Order=false)  Again, this example corresponds to a given â€œhello worldâ€� example. There is one statement inside the main  method and the order of statements doesnâ€™t matter. Another interesting Scripthonâ€™s keyword is the word  â€œAnyâ€�. It is useful for an indefinite searching. It means the searched statements can be anything, or empty. To  describe the code above, we can write:     Meth(Name=â€�mainâ€�)    Any()  But the desired code can look like this:     public static void main(String[] args) {    int i = 1;    i++;            System.out.println(args);       }  And we can find this by the following script:   Meth(Name=â€�mainâ€�)    Any()    MethCall(Name="System.out.println")  There are several more keywords supported by Scripthon. For example, Init() for a variable initialization,  Loop() for a common loop, etc. Finally, with the presented examples, it is easy to find a singleton in code:  Class() class  Block(Order=false;Consecutive=false)        Meth(Name=class.Name;Rest=private)             MethCall(Ret=class.Name;Rest=[public, static])  The only unmentioned parameter here is the â€œconsecutiveâ€� parameter. It means that the statements inside  block must not be consecutive. These statements just need to be contained somewhere in the given block.  5. Obtaining optimized trees  The Java Compiler API is used to get AST from the given Java sources in the first iteration. This API is  free and is contained in Java SDK. It provides access to control the Java compiler, and one of the compilation  outputs is an abstract syntax tree of the given sources. Just one condition needs to be met. The Java sources  must be compilable.    While browsing the Java source code, the tree, with the nodes enhanced by four numbers, is created. These  numbers are the natural numbers named left, right, level and level under. The first and the second number (left,  right) denote the order index of a node in the tree preorder traversal. Therefore, an ancestorâ€™s left index is  always smaller than its children left index, while the right index is always bigger than any childrenâ€™s right  index. The level number denotes the level in a tree hierarchy of vertices, and the level under number denotes a  124   TomÃ¡Å¡ BublÃ­k and Miroslav Virius /  IERI Procedia  10 ( 2014 )  119 â€“ 130  number of levels under the current node (compare with the method described in Yao et al., 2004).  Suppose that Ý” and Ý• are two nodes from a tree; the following rules are valid for these values.  x The  node is an ancestor of Âš and Âš is a descendant of  if Â›Ç¤ ÂŽÂ‡ÂˆÂ– àµ� Ý”Ç¤ ÂŽÂ‡ÂˆÂ– àµ� Ý•Ç¤ Ý�Ý„ÝƒÝ…ÝŽ x The  node is a parent of Âš and  is a child of  if 1) Â›Ç¤ ÂŽÂ‡ÂˆÂ– àµ� Ý”Ç¤ ÂŽÂ‡ÂˆÂ– àµ� Ý•Ç¤ Ý�Ý„ÝƒÝ…ÝŽ and 2) Â›Ç¤ ÂŽÂ‡Â˜Â‡ÂŽ àµŒ ÂšÇ¤ ÂŽÂ‡Â˜Â‡ÂŽ àµ† Í³ x The node  has áˆºáˆºÂšÇ¤ ÂŽÂ‡ÂˆÂ– àµ† ÂšÇ¤ Â”Â‹Â‰ÂŠÂ–áˆ» àµ† Í³áˆ» sub-nodes.  All these data are acquired during a single pass through the tree. Obtaining this information is not a time  consuming operation, because it is made during the tree production process. On the other hand, the number of  comparisons can be significantly reduced with these numbers.   Fig. 1. Example of AST with indexes  Fig. 2. Node â€œmainâ€� with one child  With this information (Fig. 1), we know how many children are contained in the currently processing node,  or whether a node is a leaf. Thanks to it, a lot comparisons need not to be performed. For example, comparing  this script:  Meth(Name=â€�mainâ€�)   Block(StmtNum=4)  with this Java code:  public static void main(String[] args) {  125 Tomas Bublik and Miroslav Virius /  IERI Procedia  10 ( 2014 )  119 â€“ 130           System.out.println(args);  } means that these two nodes are compared (Fig. 2.)  But the left and right indexes signalizes that the â€œmainâ€� node does have just one child, however, we search  for a method with 4 statements. So that, this code does not corresponds to the script, and any other  comparisons are not needed.  6. Comprehensive description of solution  The complete process is little bit complex, but the top overview is easy. Before the main matching  procedure,   Fig. 3. Complete process  Fig. 4. Indexing of nodes  two processes take place. The first one starts immediately after a user enters a Java sources path. It compiles  and optimizes AST obtained from the sources. This process is done just once, because the sources are always  the same in scope of this process. It runs on the background. The second process starts immediately after a  user enters a searching script. It compiles the script and, if it is not done, waits for the first process.  Next, the first iteration is performed. Matching is performed together with index building during this  iteration. After that, results are presented to a user. It is supposed that a user improves the entered script  according to the results. And then the algorithm runs again with only difference. Only the nodes  corresponding to the index of changed Scripthon part are considered.   126   TomÃ¡Å¡ BublÃ­k and Miroslav Virius /  IERI Procedia  10 ( 2014 )  119 â€“ 130  Figure 4 shows how the indexing works. Letâ€™s suppose the same â€œHelloWorldâ€� example from the  beginning of this paper. The index into the group of corresponding Java sources is assigned to all non-leaf  nodes. When a user changes the input script, the new and the old corresponding trees are compared. In our  example (Fig. 4), the â€œSystem.out.printlnâ€� method call was changed to the initiation the variable â€œiâ€� of type  int. This is indicated by gray colour. The node which contains this change is then detected by the tree  matching algorithm. It is clear that the set of corresponding Java sources to this node remains the same.  Therefore, only this set needs to be considered in the next search iteration.   These top level listings shows how the matching algorithm works:  All the source classes are iterated in a loop (line 1). Next, all the Scripthon statements are then iterated  inside this loop (line 2). The â€œcompareâ€� method is called inside the second loop. This method compares all the  sub-statements with the node from the outside loop. If there is a match, the founded result is added to the  group of results (line 7), otherwise the inner loop is beaked (line 5). According to the line 15, the â€œcompareâ€�  method calls itself recursively. First, it checks the match with prepared optimizations (line 10). The  â€œoptiMatchâ€� method (line 21) checks the structure of trees and tries to exclude the node by tree sizes  mismatch, by levels number mismatch or children number mismatch. If the â€œoptiMatchâ€� method return false,  then the node is excluded from further considerations (line 18). On contrary, when the optimizations do not  exclude the node, all the children of the statement and node are compared in the â€œcompareâ€� recursive call  (line 15). But before that, we know about the correspondence between the current statement and the current  node, therefore it is saved into memory on the line 13. If the entire children set matches, the current node is  considered equal, and true is returned from the â€œcompareâ€� method (line 19). Otherwise, false is returned (line  17). Finally, if is the node equals to all the Sripthon statements, it is saved into the results set (line 7).   7. Complexity analysis  Because the non-constant trees are compared, the complexity determination of our algorithm is not an easy  task. Syntax trees are always little bit different and since we compare the characteristics of the nodes  according to a user input, the comparison is always different. To begin, it is possible to emerge from the  complexity of the subtrees comparing algorithm. The subtree comparison problem is NP-hard. And according  to Valiente, 2002, the complexity isÜ±áˆºáˆºÝŠ à¬µ àµ… ÝŠ à¬¶ áˆ» à¬¶ áˆ», where ÝŠ à¬µ  is number of the first tree nodes whereas ÝŠ à¬¶  is  number of the second tree nodes. There exist also several improvements Shamir et al., 1999.  Our algorithm, however, is based on the use of information on the required sample tree. Thanks to this  information, a lot of comparisons can be saved. Moreover, the whole tree is traversed just once during the first  1 for(Class c from classes)   2   for (Statement s from statements)   3     match = compare(c.node, s)  4     if (!match)  5       break  6   if (match)   7     addToResults(c)  8      9 compare(Node n, Statement s)  10   match = optiMatch(n, s)   11   if (match)  12     if (n.allProperties matches s.allProperties)   13       addResultsForThisStatement(n, s);   14       for (n.children, s.children)  15         match = compare(...)   16         if (!match)   17           return false  18   else return false            19 return match     20      21 optiMatch(Node n, Statement s)   22   checkTreeSizes(n, s)  23   checkLevels(n, s)  24   checkChildrensNumber(n, s)  25 return resultOfChecks  127 Tomas Bublik and Miroslav Virius /  IERI Procedia  10 ( 2014 )  119 â€“ 130  run. During next runs, just the data, corresponding to the node containing the change, are considered.  Unfortunately, also the commands increasing the comparisons number can be written in Scripthon. For  example:  Any()  MethCall(Name="someName")  This script must run over all statements in the source code up to the â€œsomeMethodâ€� method. If the code  before this method is large, several more comparisons must be done. And moreover, it must be done even in  the case if there is no such method. This means ÝŠ more comparisons in the worst case. Another example:   Block(Order=false)  This command identifies the statements in a block. But if the statements order doesnâ€™t matter, the  algorithm must compare all the children of the â€œBlockâ€� node. If the first statement corresponds to the last  child, there will be ÝŠ  more comparisons. And if the second statement corresponds to the penultimate child,  there will be ÝŠàµ†Í³ more comparisons. In conclusion, there could be Ì±ÝŠ à¬¶  more comparisons in the worst case.  To assess whether the implemented optimization makes sense, the algorithm is equipped with the ability to  switch off the optimization globally. If we note how many comparisons actually occur in the case of enabled  optimizations, we obtain the basis to assess whether our optimization are meaningful. We chose a project with  800 Java classes as a test sample. Then several search iteration were run over this project.   When testing with disabled optimizations, nodes 142 275 comparisons were performed. On the other hand,  with enabled optimization, there was a big difference between the first run, with index gathering function, and  the following rounds, with using this index. In the first case, there were 28 268 comparisons, whilst in the  second case, there were 6 800. As can be seen, the second comparisons numbers are much lower.  8. Results  A quite common computer with Windows 7, 2,4 GHz CPU and 8 GB memory was used to test the time  complexity of our algorithm. Used Java version was 1.7.0_51. To show real benefits of our solution, we  performed several search procedures with disabled and also with enabled optimizations. We tried to identify  several important parts which could, by their time, reflect the actual contribution of the whole work.  Without  optimizations, the algorithm runs over all input classes by the â€œbrute forceâ€� method. In this case, no results  caching and no indexing was used. We compared the obtained times with times of optimized algorithm  version in Table 1.   Table 1 Times table  First round Without optimizations Optimized  Time of Java compilation 38 469 ms 39 542 ms  Time of Scripthon compilation 35 ms 33 ms  Time of search 962 ms 170 ms  Total time 39 441 ms 39 924 ms  Second round Without optimizations Optimized  Time of Java compilation 0 ms 0 ms  Time of Scripthon compilation 48 ms 44 ms  128   TomÃ¡Å¡ BublÃ­k and Miroslav Virius /  IERI Procedia  10 ( 2014 )  119 â€“ 130  Time of search 888 ms 151 ms  Time of search with change detection 68 ms 15 ms  Total time 1 062 ms 208 ms  Total time with change detection 118 ms 62 ms  As can be seen from the tables, measurements were carried out in two phases. The first table shows the  times received always in the first run of the algorithm. Both tables have two columns to indicate whether the  time was with or without the optimizations. The first significant difference is the time of compilation which is  not used in the second run. It is zero, because it does not occur in further runs.   Next row represents the times of Scripthon code compilation process. Because there werenâ€™t significant  differences between the searching scripts, these times are almost the same. Another row shows the times of  the own matching process. There is a big difference between these times. Optimized version is about 5 times  faster, however, according to the first table, this time is completely lost in the compilation time. To make  matters worse, the total time is even bigger than the time without any optimization!  The second table contains one more row. This row shows the time of matching process with help of the  index created in previous runs. In this case we used this script:   Class()     Any()      Meth(Name="add")          Init(Name="errors")   For the further runs, the only change was a name in the â€œInitâ€� statement. The algorithm used just the nodes  corresponding to â€œMeth(Name=â€�addâ€�)â€� in this case. In other words, the algorithm considered just the classes  with methods named â€œaddâ€�. As can be seen, if there is no need to compile the entire sources again, and if the  algorithm has an index created from the previous runs, the matching time acceleration is enormous. Then the  complete process runs for a tiny fraction of the time needed to run the same task without any improvement.   9. Conclusion  Our project showed that the source recognition can be speeded up highly.  The significant contribution for  the speed is the caching the nodes corresponding to statements. Although this approach speeded up the  process, however, it is necessary to say that this applies just for further runs. In the case of the first runs,  compilation of sources takes a lot of time. But there exist a lot of improvements. For example, the compilation  can start already during script wring.   This project shows the usability of programmable and dynamic code recognition in an acceptable time.  Currently, the project is used just for science purposes, but we want to add all the workaround to make it other  users. We consider also the use of the tree indexing methods to achieve even a higher speed of the matching  process in the future.  Acknowledgements  This work is supported by the SGS11/167/OHK4/3T/14 grant of the Ministry of Education, Youth and  Sports of the Czech Republic.  129 Tomas Bublik and Miroslav Virius /  IERI Procedia  10 ( 2014 )  119 â€“ 130  References  [1] TomÃ¡Å¡ BublÃ­k., Miroslav Virius. New language for searching Java code snippets. In: ITAT 2012. Proc. of  the 12th national conference ITAT. diar, Sep 17 â€“ 21 2012. Pavol Jozef Safrik University in Kosice. p. 35 â€“  40.  [2] Christophe-AndrÃ© M. Irniger. Graph Matching - Filtering Databases of Graphs Using Machine Learning  Techniques. 2005, ISBN 1-58603-557-6.  [3] B.D. McKay. Practical graph isomorphism. In Congressus Numerantium, volume 30, 1981, pages 45â€“87.  [4] J.R. Ullmann. An algorithm for subgraph isomorphism. Journal ofthe Association for Computing  Machinery, 1976, pages 31-42.  [5] G. Levi. A note on the derivation of maximal common subgraphs oftwo directed or undirected graphs.  Calcolo, 1972, pages 341-354.  [6] J. McGregor. Backtrack search algorithms and the maximal commonsubgraph problem. Software- Practice and Experience, 1982, pages 23-34.  [7]  G.A. Stephen. String Searching Algorithms. World Scientific, 1994.  [8] H. Bunke and K. Shearer. A graph distance metric based on the maximalcommon subgraph. Pattern  Recognition Letters, 1998, pages 255-259.  [9] M.-L. Fernandez and G. Valiente. A graph distance metric combining maximum common subgraph and  minimum common supergraph. Pattern Recognition Letters, 2001, pages 753-758.  [10] W.D. Wallis, P. Shoubridge, M. Kraetz, and D. Ray. Graph distances using graph union. Pattern  Recognition Letters, May 2001, pages 701-704.  [11] A. Sanfeliu and K.S. Fu. A distance measure between attributed relationalgraphs for pattern recognition.  IEEE Transactions on Systems, Man, and Cybernetics, 1983, 353-363.  [12] W.H. Tsai and K.S. Fu. Error-correcting isomorphisms of attributedrelational graphs for pattern  recognition. IEEE Transactions on Systems, Man, and Cybernetics, 1979, pages 757-768.  [13] M.A. Eshera and K.S. Fu. A graph distance measure for image analysis. IEEE Transactions on Systems,  Man, and Cybernetics, 1984, pages 398-408.  [14] E.K. Wong. Three-dimensional object recognition by attributed graphs. In H. Bunke and A. Sanfeliu,  editors, Syntactic and Structural Pattern Recognition- Theory and Applications, World Scientific, 1990, pages  381-414.  [15] R. Wilson and E.R. Hancock. Levenshtein distance for graph spectral features. In J. Kittler, M. Petrou,  and M. Nixon, editors, Proc. 17th Int. Conference on Pattern Recognition, volume 2, 2004, pages 489-492.  [16] A. Robles-Kelly and E.R. Hancock. Graph edit distance from spectral seriation. IEEE Transactions on  Pattern Analysis and Machine Intelligence, 2005, pages 365-378.  [17] T. Caelli and S. Kosinov. Inexact graph matching using eigensubspace projection clustering. Int. Journal  of Pattern Recognition and Artificial Intelligence, 2004, pages 329-355.  [18] T. Caelli and S. Kosinov. An eigenspace projection clustering method for inexact graph matching. IEEE  Transactions on Pattern Analysis and Machine Intelligence, 2004, pages 515-519.  [19] Ch. K. Roy, J. R. Cordy, and R. Koschke. 2009. Comparison and evaluation of code clone detection  techniques and tools: A qualitative approach. Sci. Comput. Program. 74, 7 (May 2009), pp. 470-495.  [20] I. D. Baxter, A. Yahin, L. Moura, M. Sant'Anna, and L. Bier. 1998. Clone Detection Using Abstract  Syntax Trees. In Proceedings of the International Conference on Software Maintenance (ICSM '98). IEEE  Computer Society, Washington, DC, USA, pp. 368-377.  [21] R. Koschke,  R.Falke, P. Frenzel. Clone Detection Using Abstract Syntax Suffix Trees, Reverse  Engineering. 2006. WCRE '06. 13th Working Conference on, ISBN 0-7695-2719-1, 2006, pages 253-262.  [22] J. T. Yao and M. Zhang. 2004. A Fast Tree Pattern Matching Algorithm for XML Query. In Proceedings  of the 2004 IEEE/WIC/ACM International Conference on Web Intelligence (WI â€™04). IEEE Computer  Society, Washington, DC, USA, pp. 235-241.  [23] G. Valiente. Algorithms on Trees and Graphs. Springer, ISBN 3540435506, 2002, page 170.  130   TomÃ¡Å¡ BublÃ­k and Miroslav Virius /  IERI Procedia  10 ( 2014 )  119 â€“ 130  [24] V. Wahler, D. Seipel, J. W. von Gudenberg, and G. Fischer. Clone detection in source code by frequent  itemset techniques. In SCAM, 2004.  [25] R. Shamir, D. Tsur. Faster Subtree Isomorphism. In Journal of Algorithms, Volume 33 Issue 2, 1999,  pages 267-280, doi:10.1006/jagm.1999.1044  . p. 35 â€“  40.  [2] Christophe-AndrÃ© M. Irniger. Graph Matching - Filtering Databases of Graphs Using Machine Learning  Techniques. 2005, ISBN 1-58603-557-6.  [3] B.D. McKay. Practical graph isomorphism. In Congressus Numerantium, volume 30, 1981, pages 45â€“87.  [4] J.R. Ullmann. An algorithm for subgraph isomorphism. Journal ofthe Association for Computing  Machinery, 1976, pages 31-42.  [5] G. Levi. A note on the derivation of maximal common subgraphs oftwo directed or undirected graphs.  Calcolo, 1972, pages 341-354.  [6] J. McGregor. Backtrack search algorithms and the maximal commonsubgraph problem. Software- Practice and Experience, 1982, pages 23-34.  [7]  G.A. Stephen. String Searching Algorithms. World Scientific, 1994.  [8] H. Bunke and K. Shearer. A graph distance metric based on the maximalcommon subgraph. Pattern  Recognition Letters, 1998, pages 255-259.  [9] M.-L. Fernandez and G. Valiente. A graph distance metric combining maximum common subgraph and  minimum common supergraph. Pattern Recognition Letters, 2001, pages 753-758.  [10] W.D. Wallis, P. Shoubridge, M. Kraetz, and D. Ray. Graph distances using graph union. Pattern  Recognition Letters, May 2001, pages 701-704.  [11] A. Sanfeliu and K.S. Fu. A distance measure between attributed relationalgraphs for pattern recognition.  IEEE Transactions on Systems, Man, and Cybernetics, 1983, 353-363.  [12] W.H. Tsai and K.S. Fu. Error-correcting isomorphisms of attributedrelational graphs for pattern  recognition. IEEE Transactions on Systems, Man, and Cybernetics, 1979, pages 757-768.  [13] M.A. Eshera and K.S. Fu. A graph distance measure for image analysis. IEEE Transactions on Systems,  Man, and Cybernetics, 1984, pages 398-408.  [14] E.K. Wong. Three-dimensional object recognition by attributed graphs. In H. Bunke and A. Sanfeliu,  editors, Syntactic and Structural Pattern Recognition- Theory and Applications, World Scientific, 1990, pages  381-414.  [15] R. Wilson and E.R. Hancock. Levenshtein distance for graph spectral features. In J. Kittler, M. Petrou,  and M. Nixon, editors, Proc. 17th Int. Conference on Pattern Recognition, volume 2, 2004, pages 489-492.  [16] A. Robles-Kelly and E.R. Hancock. Graph edit distance from spectral seriation. IEEE Transactions on  Pattern Analysis and Machine Intelligence, 2005, pages 365-378.  [17] T. Caelli and S. Kosinov. Inexact graph matching using eigensubspace projection clustering. Int. Journal  of Pattern Recognition and Artificial Intelligence, 2004, pages 329-355.  [18] T. Caelli and S. Kosinov. An eigenspace projection clustering method for inexact graph matching. IEEE  Transactions on Pattern Analysis and Machine Intelligence, 2004, pages 515-519.  [19] Ch. K. Roy, J. R. Cordy, and R. Koschke. 2009. Comparison and evaluation of code clone detection  techniques and tools: A qualitative approach. Sci. Comput. Program. 74, 7 (May 2009), pp. 470-495.  [20] I. D. Baxter, A. Y</xocs:rawtext><xocs:serial-item><article xmlns="http://www.elsevier.com/xml/ja/dtd" version="5.2" xml:lang="en" docsubtype="fla"><item-info><jid>IERI</jid><aid>465</aid><ce:pii>S2212-6678(14)00148-8</ce:pii><ce:doi>10.1016/j.ieri.2014.09.100</ce:doi><ce:copyright type="other" year="2014">The Authors</ce:copyright></item-info><head><ce:article-footnote><ce:label>☆</ce:label><ce:note-para id="npar0005" view="all">Selection and peer review under responsibility of Information Engineering Research Institute.</ce:note-para></ce:article-footnote><ce:title id="tit0005">Scripting Language for Java Source Code Recognition</ce:title><ce:author-group id="aug0005"><ce:author id="aut0005"><ce:given-name>Tomáš</ce:given-name><ce:surname>Bublík</ce:surname><ce:cross-ref id="crf0005" refid="cor0005"><ce:sup loc="post">⁎</ce:sup></ce:cross-ref><ce:e-address id="eadd0005" type="email">tomas.bublik@gmail.com</ce:e-address></ce:author><ce:author id="aut0010"><ce:given-name>Miroslav</ce:given-name><ce:surname>Virius</ce:surname></ce:author><ce:affiliation id="aff0005"><ce:textfn>Faculty of Nuclear Sciences and Physical Engineering Czech Technical University in Prague, Trojanova 13, Prague, 120 00, Czech Republic</ce:textfn></ce:affiliation><ce:correspondence id="cor0005"><ce:label>⁎</ce:label><ce:text>Corresponding author. Tel.: +420605155484.</ce:text></ce:correspondence></ce:author-group><ce:abstract id="abs0005" view="all" class="author"><ce:section-title id="sect0005">Abstract</ce:section-title><ce:abstract-sec id="abst0005" view="all"><ce:simple-para id="spar0005" view="all">This paper presents general results on the Java source code snippet detection problem. We propose the tool which uses graph and subgraph isomorphism detection. A number of solutions for all of these tasks have been proposed in the literature. However, although that all these solutions are really fast, they compare just the constant static trees. Our solution offers to enter an input sample dynamically with the Scripthon language while preserving an acceptable speed. We used several optimizations to achieve very low number of comparisons during the matching algorithm.</ce:simple-para></ce:abstract-sec></ce:abstract><ce:keywords id="kwd0005" class="keyword" view="all"><ce:section-title id="sect0010">Keywords</ce:section-title><ce:keyword id="kw0005"><ce:text>AST</ce:text></ce:keyword><ce:keyword id="kw0010"><ce:text>Java</ce:text></ce:keyword><ce:keyword id="kw0015"><ce:text>tree matching</ce:text></ce:keyword><ce:keyword id="kw0020"><ce:text>Scriphon</ce:text></ce:keyword><ce:keyword id="kw0025"><ce:text>source code recognition</ce:text></ce:keyword></ce:keywords></head><tail view="all"><ce:bibliography id="bibl0005" view="all"><ce:section-title id="sect0020">References</ce:section-title><ce:bibliography-sec id="bibs0005" view="all"><ce:bib-reference id="bib0005"><ce:label>[1]</ce:label><ce:other-ref id="oref0005"><ce:textref>Tomáš Bublík., Miroslav Virius. New language for searching Java code snippets. In: ITAT 2012. Proc. of the 12th national conference ITAT. diar, Sep 17-21 2012. Pavol Jozef Safrik University in Kosice. p. 35-40.</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0010"><ce:label>[2]</ce:label><ce:other-ref id="oref0010"><ce:textref>Christophe-André M. Irniger. Graph Matching - Filtering Databases of Graphs Using Machine Learning Techniques. 2005, ISBN 1-58603-557-6.</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0015"><ce:label>[3]</ce:label><sb:reference id="sbref0015"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>B.D.</ce:given-name><ce:surname>McKay</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Practical graph isomorphism</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>In Congressus Numerantium</sb:maintitle></sb:title><sb:volume-nr>30</sb:volume-nr></sb:series><sb:date>1981</sb:date></sb:issue><sb:pages><sb:first-page>45</sb:first-page><sb:last-page>87</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0020"><ce:label>[4]</ce:label><sb:reference id="sbref0020"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>J.R.</ce:given-name><ce:surname>Ullmann</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>An algorithm for subgraph isomorphism</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Journal ofthe Association for Computing Machinery</sb:maintitle></sb:title></sb:series><sb:date>1976</sb:date></sb:issue><sb:pages><sb:first-page>31</sb:first-page><sb:last-page>42</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0025"><ce:label>[5]</ce:label><sb:reference id="sbref0025"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>G.</ce:given-name><ce:surname>Levi</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>A note on the derivation of maximal common subgraphs oftwo directed or undirected graphs</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Calcolo</sb:maintitle></sb:title></sb:series><sb:date>1972</sb:date></sb:issue><sb:pages><sb:first-page>341</sb:first-page><sb:last-page>354</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0030"><ce:label>[6]</ce:label><sb:reference id="sbref0030"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>J.</ce:given-name><ce:surname>McGregor</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Backtrack search algorithms and the maximal commonsubgraph problem</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Software-Practice and Experience</sb:maintitle></sb:title></sb:series><sb:date>1982</sb:date></sb:issue><sb:pages><sb:first-page>23</sb:first-page><sb:last-page>34</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0035"><ce:label>[7]</ce:label><ce:other-ref id="oref0035"><ce:textref>G.A. Stephen. String Searching Algorithms. World Scientific, 1994.</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0040"><ce:label>[8]</ce:label><sb:reference id="sbref0040"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>H.</ce:given-name><ce:surname>Bunke</ce:surname></sb:author><sb:author><ce:given-name>K.</ce:given-name><ce:surname>Shearer</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>A graph distance metric based on the maximalcommon subgraph</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Pattern Recognition Letters</sb:maintitle></sb:title></sb:series><sb:date>1998</sb:date></sb:issue><sb:pages><sb:first-page>255</sb:first-page><sb:last-page>259</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0045"><ce:label>[9]</ce:label><ce:other-ref id="oref0045"><ce:textref>M.-L. Fernandez, G. Valiente. A graph distance metric combining maximum common subgraph and minimum common supergraph. Pattern Recognition Letters, 2001, pages 753-758.</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0050"><ce:label>[10]</ce:label><ce:other-ref id="oref0050"><ce:textref>W.D. Wallis, P. Shoubridge, M. Kraetz, D. Ray. Graph distances using graph union. Pattern Recognition Letters, May 2001, pages 701-704.</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0055"><ce:label>[11]</ce:label><sb:reference id="sbref0055"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>A.</ce:given-name><ce:surname>Sanfeliu</ce:surname></sb:author><sb:author><ce:given-name>K.S.</ce:given-name><ce:surname>Fu</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>A distance measure between attributed relationalgraphs for pattern recognition</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>IEEE Transactions on Systems, Man, and Cybernetics</sb:maintitle></sb:title></sb:series><sb:date>1983</sb:date></sb:issue><sb:pages><sb:first-page>353</sb:first-page><sb:last-page>363</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0060"><ce:label>[12]</ce:label><sb:reference id="sbref0060"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>W.H.</ce:given-name><ce:surname>Tsai</ce:surname></sb:author><sb:author><ce:given-name>K.S.</ce:given-name><ce:surname>Fu</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Error-correcting isomorphisms of attributedrelational graphs for pattern recognition</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>IEEE Transactions on Systems, Man, and Cybernetics</sb:maintitle></sb:title></sb:series><sb:date>1979</sb:date></sb:issue><sb:pages><sb:first-page>757</sb:first-page><sb:last-page>768</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0065"><ce:label>[13]</ce:label><sb:reference id="sbref0065"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>M.A.</ce:given-name><ce:surname>Eshera</ce:surname></sb:author><sb:author><ce:given-name>K.S.</ce:given-name><ce:surname>Fu</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>A graph distance measure for image analysis</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>IEEE Transactions on Systems, Man, and Cybernetics</sb:maintitle></sb:title></sb:series><sb:date>1984</sb:date></sb:issue><sb:pages><sb:first-page>398</sb:first-page><sb:last-page>408</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0070"><ce:label>[14]</ce:label><ce:other-ref id="oref0070"><ce:textref>E.K. Wong. Three-dimensional object recognition by attributed graphs. In H. Bunke and A. Sanfeliu, editors, Syntactic and Structural Pattern Recognition- Theory and Applications, World Scientific, 1990, pages 381-414.</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0075"><ce:label>[15]</ce:label><ce:other-ref id="oref0075"><ce:textref>R. Wilson and E.R. Hancock. Levenshtein distance for graph spectral features. In J. Kittler, M. Petrou, and M. Nixon, editors, Proc. 17th Int. Conference on Pattern Recognition, volume 2, 2004, pages 489-492.</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0080"><ce:label>[16]</ce:label><ce:other-ref id="oref0080"><ce:textref>A. Robles-Kelly and E.R. Hancock. Graph edit distance from spectral seriation. IEEE Transactions on Pattern Analysis and Machine Intelligence, 2005, pages 365-378.</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0085"><ce:label>[17]</ce:label><sb:reference id="sbref0085"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>T.</ce:given-name><ce:surname>Caelli</ce:surname></sb:author><sb:author><ce:given-name>S.</ce:given-name><ce:surname>Kosinov</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>Inexact graph matching using eigensubspace projection clustering</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>Int. Journal of Pattern Recognition and Artificial Intelligence</sb:maintitle></sb:title></sb:series><sb:date>2004</sb:date></sb:issue><sb:pages><sb:first-page>329</sb:first-page><sb:last-page>355</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0090"><ce:label>[18]</ce:label><sb:reference id="sbref0090"><sb:contribution langtype="en"><sb:authors><sb:author><ce:given-name>T.</ce:given-name><ce:surname>Caelli</ce:surname></sb:author><sb:author><ce:given-name>S.</ce:given-name><ce:surname>Kosinov</ce:surname></sb:author></sb:authors><sb:title><sb:maintitle>An eigenspace projection clustering method for inexact graph matching</sb:maintitle></sb:title></sb:contribution><sb:host><sb:issue><sb:series><sb:title><sb:maintitle>IEEE Transactions on Pattern Analysis and Machine Intelligence</sb:maintitle></sb:title></sb:series><sb:date>2004</sb:date></sb:issue><sb:pages><sb:first-page>515</sb:first-page><sb:last-page>519</sb:last-page></sb:pages></sb:host></sb:reference></ce:bib-reference><ce:bib-reference id="bib0095"><ce:label>[19]</ce:label><ce:other-ref id="oref0095"><ce:textref>Ch. K. Roy, J.R. Cordy, and R. Koschke. 2009. Comparison and evaluation of code clone detection techniques and tools: A qualitative approach. Sci. Comput. Program. 74, 7 (May 2009), pp. 470-495.</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0100"><ce:label>[20]</ce:label><ce:other-ref id="oref0100"><ce:textref>I. D. Baxter, A. Yahin, L. Moura, M. Sant’Anna, and L. Bier. 1998. Clone Detection Using Abstract Syntax Trees. In Proceedings of the International Conference on Software Maintenance (ICSM ‘98). IEEE Computer Society, Washington, DC, USA, pp. 368-377.</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0105"><ce:label>[21]</ce:label><ce:other-ref id="oref0105"><ce:textref>R. Koschke, R. Falke, P. Frenzel. Clone Detection Using Abstract Syntax Suffix Trees, Reverse Engineering. 2006. WCRE ‘06. 13th Working Conference on, ISBN 0-7695-2719-1, 2006, pages 253-262.</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0110"><ce:label>[22]</ce:label><ce:other-ref id="oref0110"><ce:textref>J. T. Yao and M. Zhang. 2004. A Fast Tree Pattern Matching Algorithm for XML Query. In Proceedings of the 2004 IEEE/WIC/ACM International Conference on Web Intelligence (WI ‘04). IEEE Computer Society, Washington, DC, USA, pp. 235-241.</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0115"><ce:label>[23]</ce:label><ce:other-ref id="oref0115"><ce:textref>G. Valiente. Algorithms on Trees and Graphs. Springer, ISBN 3540435506, 2002, page 170.</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0120"><ce:label>[24]</ce:label><ce:other-ref id="oref0120"><ce:textref>V. Wahler, D. Seipel, J.W. von Gudenberg, and G. Fischer. Clone detection in source code by frequent itemset techniques. In SCAM, 2004.</ce:textref></ce:other-ref></ce:bib-reference><ce:bib-reference id="bib0125"><ce:label>[25]</ce:label><ce:other-ref id="oref0125"><ce:textref>R. Shamir, D. Tsur. Faster Subtree Isomorphism. In Journal of Algorithms, Volume 33 Issue 2, 1999, pages 267-280, doi:10.1006/jagm.1999.1044.</ce:textref></ce:other-ref></ce:bib-reference></ce:bibliography-sec></ce:bibliography></tail></article></xocs:serial-item></xocs:doc></originalText></full-text-retrieval-response>