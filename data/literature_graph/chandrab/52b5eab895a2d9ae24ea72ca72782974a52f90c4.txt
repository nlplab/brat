Title: Relation Extraction with Matrix Factorization and Universal Schemas

Abstract: Traditional relation extraction predicts relations within some fixed and finite target schema. Machine learning approaches to this task require either manual annotation or, in the case of distant supervision, existing struc-tured sources of the same schema. The need for existing datasets can be avoided by using a universal schema: the union of all involved schemas (surface form predicates as in OpenIE, and relations in the schemas of pre-existing databases). This schema has an almost unlimited set of relations (due to surface forms), and supports integration with existing structured data (through the relation types of existing databases). To populate a database of such schema we present matrix factorization models that learn latent feature vectors for entity tuples and relations. We show that such latent models achieve substantially higher accuracy than a traditional classification approach. More importantly, by operating simultaneously on relations observed in text and in pre-existing structured DBs such as Freebase, we are able to reason about unstructured and structured data in mutually-supporting ways. By doing so our approach outperforms state-of-the-art distant supervision.

Content: Introduction

Most previous work in relation extraction uses a predefined , finite and fixed schema of relation types (such as born-in or employed-by). Usually some textual data is labeled according to this schema, and this labeling is then used in supervised training of an automated relation extractor, e.g. Culotta and Sorensen (2004). However, labeling textual relations is time-consuming and difficult, leading to significant recent interest in distantly-supervised learning . Here one aligns existing database records with the sentences in which these records have been " rendered " ––effectively labeling the text—and from this labeling we can train a machine learning system as before (Craven and Kumlien, 1999; Mintz et al., 2009; Bunescu and Mooney, 2007; Riedel et al., 2010). However, this method relies on the availability of a large database that has the desired schema. The need for pre-existing datasets can be avoided by using language itself as the source of the schema. This is the approach taken by OpenIE (Etzioni et al., 2008). Here surface patterns between mentions of concepts serve as relations. This approach requires no supervision and has tremendous flexibility, but lacks the ability to generalize. For example, OpenIE may find FERGUSON–historian-at–HARVARD but does not know FERGUSON–is-a-professor-at– HARVARD. OpenIE has traditionally relied on a large diversity of textual expressions to provide good coverage. But this diversity is not always available, and, in any case, the lack of generalization greatly inhibits the ability to support reasoning. One way to gain generalization is to cluster textual surface forms that have similar meaning (Lin and Pantel, 2001; Pantel et al., 2007; Yates and Etzioni, 2009; Yao et al., 2011). While the clusters discovered by all these methods usually contain semantically related items, closer inspection invariably shows that they do not provide reliable implicature . For example, a typical representative cluster may include historian-at, professor-at, scientistat , worked-at. Although these relation types are indeed semantically related, note that scientist-at does not necessarily imply professor-at, and worked-at certainly does not imply scientist-at. In fact, we contend that any relational schema would inherently be brittle and ill-defined––having ambiguities, problematic boundary cases, and incompleteness. 1 For example, Freebase, in spite of its extensive effort towards high coverage, has no critized nor scientist-at relation. In response to this problem, we present a new approach: implicature with universal schemas. Here we embrace the diversity and ambiguity of original inputs; we avoid forcing textual meaning into predefined boxes. This is accomplished by defining our schema to be the union of all source schemas: original input forms, e.g. variants of surface patterns similarly to OpenIE, as well as relations in the schemas of many available pre-existing structured databases. But then, unlike OpenIE, our focus lies on learning asymmetric implicature among relations. This allows us to probabilistically " fill in " inferred unobserved entity-entity relations in this union. For example, after observing FERGU- SON–historian-at–HARVARD our system infers that FERGUSON–professor-at–HARVARD, but not vice versa. At the heart of our approach is the hypothesis that we should concentrate on predicting source data––a relatively well defined task that can be evaluated and optimized––as opposed to modeling semantic equivalence , which we believe will always be illusive. Note that by operating simultaneously on relations observed in text and in pre-existing structured databases such as Freebase, we are able to reason about unstructured and structured data in mutuallysupporting ways. For example, we can predict surface pattern relations that effectively serve as additional features when predicting Freebase relations, hence improving generalization. Also notice that users of our system will not have to study and understand the complexities of a particular schema in order to issue queries; they can ask in whatever form naturally occurs to them, and our system will likely already have that relation in our universal schema. Our technical approach is based on extensions to probabilistic models of matrix factorization and 1 At NAACL 2012 Lucy Vanderwende asked " Where do the relation types come from? " There was no satisfying answer. At the same meeting, and in line with Brachman (1983), Ed Hovy stated " We don't even know what is-a means. " collaborative filtering (Collins et al., 2001; Koren, 2008; Rendle et al., 2009). We represent the probabilistic knowledge base as a matrix with entityentity pairs in the rows and relations in the columns (see figure 1). The rows come from running crossdocument entity resolution across pre-existing structured databases and textual corpora. The columns come from the union of surface forms and DB relations . We present a series of models that learn lower dimensional manifolds for tuples, relations and entities , and a set of weights that capture direct correlations between relations. Weights and lower dimensional representations act, through dot products, as the natural parameters of a single log-linear model to derive per-cell probabilities. In experiments we show that our models can accurately predict surface patterns relationships which do not appear explicitly in text, and that learning latent representations of entities, tuples and relations substantially improves results over a traditional classifier approach. Moreover, we can improve accuracy by simultaneously operating on relations observed in the New York Times corpus and in Freebase . In particular, our model outperforms the current state-of-the-art distant supervision method (Surdeanu et al., 2012) by 10% points Mean Average Precision through joint implicature among surface patterns and Freebase relations.

Model

Before we present our approach in more detail, we briefly introduce some notation. We use R to denote the set of relations we seek to predict (such as works-written in Freebase, or the X–historian-at–Y pattern), and T to denote the set of input tuples. For simplicity we assume each relation to be binary, although our approach can be easily generalized to the n-ary case. Given a relation r ∈ R and a tuple t ∈ T the pair r, t is a fact, or relation instance. The input to our model is a set of observed facts O, and the observed facts for a given tuple is denoted by O t := {{r, t ∈ O}. Our goal is a model that can estimate, for a given relation r (such as X–historian-at–Y) and a given tuple t (such as <FERGUSON,HARVARD>), the probability p (y r,t = 1) where y r,t is a binary random variable that is true iff t is in relation r. We Train 0.95 Test Surface Patterns KB Relations X-professor-at-Y 1 1 0.05 X-historian-at-Y employee(X,Y) member(X,Y) 1 1 1 1 0.97 Rel. Extraction 1 0.93 0.97 Cluster Align Reasoning with Universal Schema Ferguson,Harvard Oman,Oxford Firth,Oxford Gödel,Princeton 0.95 Figure 1: Filling up a database of universal schema. Dark circles are observed facts, shaded circles are inferred facts. Relation Extraction (RE) maps surface pattern relations (and other features) to structured relations. Surface form clustering models correlations between patterns , and can be fed into RE (Yao et al., 2011). Database alignment and integration models correlations between structured relations (not done in this work). Reasoning with the universal schema incorporates these tasks in a joint fashion. introduce a series of exponential family models that estimate this probability using a natural parameter θ r,t and the logistic function: p (y r,t = 1|θ r,t ) := σ (θ r,t ) = 1 1 + exp (−θ r,t ) . We will first describe our models through different definitions of the natural parameter θ r,t . In each case θ r,t will be a function of r, t and a set of weights and/or latent feature vectors. In section 2.5 we will then show how these weights and vectors can be estimated based on the observed facts O. Notice that we can interpret p (y r,t = 1) as the probability that a customer t likes product r. This analogy allows us to draw from a large body of work in collaborative filtering, such as work in probabilistic matrix factorization and implicit feedback.

Latent Feature Model

One way to define θ r,t is through a latent feature model F. Here we measure compatibility between relation r and tuple t as dot product of two latent feature representations of size K F : a r for relation r, and v t for tuple t. This gives: θ F r,t := K F k a r,k v t,k . This corresponds to generalized PCA (Collins et al., 2001), a model were the matrix Θ = (θ r,t ) of natural parameters is defined as the low rank factorization AV. Notice that we intentionally omit any per-relation bias-terms. In section 4 we evaluate ranked answers to queries on a per-relation basis, and a per-relation bias term will have no effect on ranking facts of the same relation. Also consider that such latent feature models can capture asymmetry by assigning more peaked vectors to specific relations, and more uniform vectors to general relations.

Neighborhood Model

We can interpolate the confidence for a given tuple and relation based on the trueness of other similar relations for the same tuple. In collaborative filtering this is referred to as a neighborhood-based approach (Koren, 2008). In terms of our natural parameter , we implement a neighborhood model N via a set of weights w r,r , where each corresponds to a directed association strength between relations r and r . For a given tuple t and relation r we then sum up the weights corresponding to all relations r that have been observed for tuple t: θ N r,t := (r ,t)∈O\{(r,t)} w r,r . Notice that the neighborhood model amounts to a collection of local log-linear classifiers, one for each relation r with feature functions f r,r (t) = I [r = r ∧ (r , t) ∈ O] and weights w r . This means that in contrast to model F, this model cannot harness any synergies between textual and pre-existing DB relations.

Entity Model

Relations have selectional preferences: they allow only certain types in their argument slots. While knowledge bases such as Freebase or DBPedia have extensive ontologies of types of entities, these are often not sufficiently fine to allow relations to discriminate (Yao et al., 2012b). Hence, instead of using a predetermined set of entity types, in our entity model E we learn a latent entity representation from data. More concretely, for each entity e we introduce a latent feature vector t e of dimension K E . In addition, for each relation r and argument slot i we introduce a feature vector d i of the same dimension. For example , binary relations have feature representations d 1 for argument 1, and d 2 for argument 2. Measuring compatibility of an entity tuple and relation amounts to measuring, and summing up, compatibility between each argument slot representation and the corresponding entity representation. This leads to: θ E r,t := arity(r) i=1 K E k d i,k t t i ,k . Note that due to entity resolution, tuples may share entities, and hence parameters are shared across rows.

Combined Model

In practice all the above models can capture important aspects of the data. Hence we also use various combinations, such as: θ NFE r,t := θ N r,t + θ F r,t + θ E r,t . 2.5 Parameter Estimation Our models are parametrized through weights and latent component vectors. We could estimate these parameters by maximizing the loglikelihood of the observed data akin to Collins et al. (2001). However , as we do not have access to negative facts, the model would simply learn to predict all facts to be true. In our initial attempt to overcome this issue we sampled a set of unobserved facts as designated negative facts, as is done in related distant supervision approaches. However, we found that (a) our results were sensitive to the choice of negative data and (b) runtime was increased substantially because of a large number of required negative facts. In collaborative filtering positive-only data is also known as implicit feedback. This type of feedback arises, for example, when users buy but not rate items. One successful approach to learning with implicit feedback is based on the observation that the actual task is not necessarily one of prediction (here: to predict a number between 0 and 1) but one of (generally simpler) ranking: to give true " user-item " cells higher scores than false ones. Bayesian Personalized Ranking (BPR) uses a variant of this ranking: giving observed true facts higher scores than unobserved (true or false) facts (Rendle et al., 2009). This relaxed constraint is to be contrasted with the loglikelihood setting that essentially requires (randomly sampled) negative facts to score below a globally defined threshold.

Objective

We first create a dataset of ranked pairs: for each relation r and each observed fact f + := r, t + ∈ O we choose all tuples t − such that f − := r, t − / ∈ O—that is, tuples we have not observed to be in relation r. For each pair of facts f + and f − we want p (f + ) > p (f − ) and hence θ f + > θ f − . In BPR this is achieved by maximizing a sum terms of the form Obj f + ,f − := log σ θ f + − θ f − , one for each ranked pair: Obj := r,t + ∈O r,t − / ∈O Obj r,t + ,r,t − . (1) Notice that this objective differs slightly from the one used by Rendle et al. (2009). Consider tuples as users and items as relations. We rank different users with respect to the same item, while BPR ranks items with respect to the same user. Also notice that the BPR objective is an approximation to the perrelation AUC (area under the ROC curve), and hence directly correlated to what we want to achieve: wellranked tuples per relation. Note that all parameters are regularized with quadratic penalty which we omit here for brevity. we sample |O| facts with replacement from O. For each sampled fact r, t + we then sample a tuple t − ∈ T such that r, t − / ∈ O is not an observed fact. This gives us |O| fact pairs f + , f − , and for each pair we do an SGD update using the corresponding gradients of Obj f + ,f − . For the F model the gradients correspond to those presented by Rendle et al. (2009). The remaining gradients are easy to derive; we omit details for brevity.

Related Work

This work extends a previous workshop paper (Yao et al., 2012a) by introducing the neighborhood and entity model, by working with the BPR objective, and by more extensive experiments.

Relational

Clustering There is a large body of work aiming to discover latent relations by clustering surface patterns (Hasegawa et al., 2004; Shinyama and Sekine, 2006; Kok and Domingos, 2008; Yao et al., 2011; Takamatsu et al., 2011), or by inducing synonymy relationships between patterns independently of the entities (Yates and Etzioni , 2009; Pantel et al., 2007; Lin and Pantel, 2001). Our approach has a fundamentally different objective: we are not (primarily) interested in clusters of patterns or their semantic representation, but in predicting patterns where they are not observed. Moreover, these related methods rely on a symmetric notion of synonymy in which clustered patterns are assumed to have the same meaning. Our approach rejects this assumption in favor of a model which learns that certain patterns, or combinations thereof, entail others in one direction, but not necessarily the other. This is similar in spirit to work on learning entailment rules (Szpektor et al., 2004; Zanzotto et al., 2006; Szpektor and Dagan, 2008). However, for us even entailment rules are just a by-product of our goal to improve prediction, and it is this goal we directly optimize for and evaluate.

Matrix Factorization

Our approach is also related to work on factorizing YAGO to predict new links (Nickel et al., 2012). The primary differences are that we include surface patterns in our schema, use a ranking objective, and learn latent vectors for entities and tuples. Likewise, matrix factorization in various flavors has received significant attention in the lexical semantics community, from LSA to recent work on non-negative sparse embeddings (Murphy et al., 2012). In our problem columns correspond to relations, and rows correspond to entity tuples . By contrast, there columns are words, and rows are contextual features such as " words in a local window . " Consequently, our objective is to complete the matrix, whereas their objective is to learn better latent embeddings of words (which by themselves again cannot capture any sense of asymmetry). OpenIE Open IE (Etzioni et al., 2008) extracts facts mentioned in text, but does not predict potential facts not mentioned in text. Finding answers requires explicit mentions, and hence suffers from lower recall for not-so-frequently mentioned facts. Methods that learn rules between textual patterns in OpenIE aim at a similar goal as our proposed approach (Schoenmackers et al., 2008; Schoenmackers et al., 2010). However, their approach is substantially more complex, requires a categorization of entities into fine grained entity types, and needs inference in high tree-width Markov Networks. By contrast, our approach is based on a single unified model, requires no entity types, and for us inferring a fact amounts to not more than a few dot products. In addition, in our Universal Schema approach OpenIE surface patterns are just one kind of relations, and our aim is populate relations of all kinds. In the future we may even include relations between entities and continuous attributes (say, gene expression measurements). Distant Supervision In Distant Supervision (DS) a set of facts from pre-existing structured sources is aligned with surface patterns mentioned in text (Bunescu and Mooney, 2007; Mintz et al., 2009; Riedel et al., 2010; Hoffmann et al., 2011; Surdeanu et al., 2012), and this alignment is then used to train a relation extractor. A core difference to our approach is the number of target relations: In DS it is the relatively small schema size of the knowledge base, while we also include surface patterns. This allows us to answer more expressive queries. Moreover , by learning from surface-pattern correlations, our latent models induce feature representations for patterns that do not appear in the DS training set. As we will see in section 4, this allows us to outperform state-of-the-art DS models.

Never-Ending Learning and Bootstrapping

Our latent feature models are capable of never-ending learning (Carlson et al., 2010). That is, we can continue to train these models with incoming data, even if no structured annotation is available. In bootstrapping approaches the current model is used to predict new relations, and these hypothesized relations are used as new supervision targets (i.e. self-training). By contrast, our model only strengthens the correlations between incoming co-occurring observations. This has the advantage that wrong predictions are less likely be reinforced, hence reducing the risk of semantic drift.

Experiments

How accurately can we fill a database of Universal Schema, and does reasoning jointly across a universal schema help to improve over more isolated approaches? In the following we seek to answer this question empirically. To this end we train our models on observed facts in a newswire corpus and Freebase, and then manually evaluate ranked predictions: first for structured relations and then for surface form relations.

Data

Following previous work (Riedel et al., 2010), our documents are taken from the NYTimes corpus (Sandhaus, 2008). Articles after 2000 are used as training corpus, articles from 1990 to 1999 as test corpus. We also split Freebase facts 50/50 into train and test facts, and their corresponding tuples into train and test tuples. Then we align training tuples with the training corpus, and test tuples with the test corpus. This alignment relies on a preprocessing step that links NER mentions in text with entities in Freebase. In our case we use a simple string-match heuristic to find this linking. Now we align an entity tuple t 1 , t 2 with a pair of mentions m 1 , m 2 in the same sentence if m 1 is linked to t 1 and m 2 to t 2 . Based on this alignment we filter out all relations for which we find fewer than 10 tuples with mentions in text. The above alignment and filtering process reduces the total number of tuples related according to Freebase to 16k: approximately 8k tuples with facts mentioned in the training set, and approximately 8k such tuples for the test set. In addition we have a set of approximately 200k training tuples for which both arguments appear in the same sentence and both can be linked to Freebase entities, but for which no Freebase fact is recorded. This can either be because they are not related, or simply because Freebase does not contain the relationship yet. We also have about 200k such tuples in the test set. To simplify evaluation, we create a subsampled test set by randomly choosing 10k of the original test set tuples. The above alignment allows us to determine, for each tuple t, the observed facts O t as follows. To find the surface pattern facts O PAT t for the tuple t = t 1 , t 2 we extract, for each mention m = m 1 , m 2 of t, the lexicalized dependency path p between m 1 and m 2 . Then we add p, t to O PAT t . For example, we get " <-subj<-head->obj-> " for " M1 heads M2. " Filtering out patterns with fewer than 10 mentions in text yields approximately 4k patterns. For training tuples we add as Freebase facts O FB t all facts r, t that appear in Freebase, and for which r has not been filtered out beforehand. For the test set O FB t remains empty. The total set of observed facts O t is O FB t ∪O PAT t , and their union over all tuples forms the set of observed facts O.

Evaluation

For evaluation we use collections of relations: surface patterns in one experiment and Freebase relations in the other. In either case we compare the competing systems with respect to their ranked results for each relation in the collection. Given this ranking task, our evaluation is inspired by the TREC competitions and work in information retrieval (Manning et al., 2008). That is, we treat each relation as query and receive the top 1000 (run depth) entity pairs from each system. Then we pool the top 100 (pool depth) answers from each system and manually judge their relevance or " truth. " This gives a set of relevant results that we can use to calculate recall and precision measures. In particular, we can use these annotations to measure an average precision across the precision-recall curve, and an aggregate mean average precision (MAP) across all relations. This metric has shown to be very robust and stable (Manning et al., 2008). In addition we also present a weighted version of MAP (weighted MAP) in which the average precision for each Freebase relations based on pooled results. The # column shows the number of true facts in the pool. NFE is statistically different to all but NF and F according to the sign test. Bold faced are winners per relation, italics indicate ties. lation is weighted by the relation's number of true facts. Notice that we deviate from previous work in distant supervision that (a) combines the results from several relations in a single precision recall curve, and (b) uses held-out evaluation to measure how well the predictions match existing Freebase facts. This has several benefits. First, when aggregating across relations results are often dominated by a few very frequent relations, such as containedby, providing little information about how the models perform across the board. Second, evaluating with Freebase held-out data is biased. For example, we find that frequently mentioned entity pairs are more likely to have relations in Freebase. Systems that rank such tuples higher receives higher precision than those that do not have such bias, regardless of how correct their predictions are. Third, we can aggregate per-relation comparisons to establish statistical significance , for example via the sign test. Also note that while we run our models on the complete training and test set, evaluation is restricted to the subsampled test set.

Predicting Freebase Relations

Table 1 shows our results for Freebase relations, omitting those for which none of the systems can find any relevant facts. Our first baseline is MI09, a distantly supervised classifier based on the work of Mintz et al. (2009). This classifier only learns from observed pattern-relation pairs in the training set (of which we only have about 8k). By contrast, our latent feature models can learn pattern-pattern correlations both on the unlabeled training and test set (comparable to bootstrapping). We hence also compare against YA11, a version of MI09 that uses preprocessed cluster features according to Yao et al. (2011). The third baseline is SU12, the state-of-theart Multi-Instance Multi-Label system by Surdeanu et al. (2012). The remaining systems are our neighborhood 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.2 0.4 0.6 0. 8 1 Figure 2: Averaged 11-point precision recall curve for Freebase relations in table 1. model (N), the factorized model (F), their combination (NF) and the combined model with a latent entity representation (NFE). For all our models we use the same number of components when applicable (K F = K E = 100), 1000 epochs, and 0.01 as regularizer for component weights and 0.1 for neighborhood weights. Table 1 shows that adding pattern cluster features (and hence incorporating more data) helps YA11 to improve over MI09. Likewise, we see that the factorized model F improves over N, again learning from unlabeled data. This improvement is bigger than the corresponding change between MI09 and YA11, possibly indicating that our latent representations are optimized directly towards improving prediction performance. The combination of N, F and E outperforms all other models in terms of weighted MAP, indicating the power of selectional preferences learned from data. Note that NFE is significantly different (p 0.05 in sign test) to all but the NF and F models. In terms of MAP the NF model outperforms NFE, indicating that it does not do as well for frequent relations, but better for infrequent ones. Figure 2 shows an averaged 11-point precision recall graph (Manning et al., 2008) for Freebase relations . We notice that our latent models outperform all remaining models across all recall levels, and that combining neighborhood and latent models is helpful. This finding is consistent with our MAP results. Figure 3 shows the recall-precision curve for the works_written relation with respect to our three baselines and the NFE model. Observe how 0 0.2 0.4 0.6 0.8 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision Recall Recall/Precision MI09 YA11 SU12 NFE Figure 3: Precision and recall for works_written(X,Y). sion drops for both MI09 and SU12 at about 50% recall. At this point the remaining unretrieved facts have patterns that have not been seen together with works_written in the training set. By using cluster features, YA11 can overcome this problem partly, but not as dramatically as NFE—a pattern we observe for many relations. All our models are fast to train. The slowest model trains in just 45 minutes. By contrast, training the topic model in YA11 alone takes 4 hours. Training SU12 takes two hours (on less data). Also notice that our models not only learn to predict Freebase relations, but also approximately 4k surface pattern relations.

Predicting Surface Patterns

Table 2 presents a comparison of our models with respect to 10 surface pattern relations. These relations 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.2 0.4 0.6 0.8 1 Precision

Recall

Averaged 11-point Precision/Recall N F NF NFE Figure 4: Averaged 11-point precision recall curve for surface pattern relations in table 2. were chosen according to what we believe are interesting questions not currently captured in Freebase. We again see that learning a latent representation (F, NF and NFE) from additional data helps quite substantially over the N model. For in the weighted MAP metric we note that incorporating entity representations (in the NFE model) in fact hurts total performance. 3 One reason may be the fact that Freebase relations are typed—they require very specific types of entities as arguments. By contrast, for a surface pattern like " X visits Y " X could be a person or organization, and Y could be a location, organization or person. However, in terms of MAP score this time there is no obvious winner among the latent models. This is also confirmed by the averaged 11-point precision recall curve in figure 4. Notice that we can accurately predict the X– scientist-at–Y surface pattern relation in table 2, as well as the more general person/company (employedBy ) relation in table 1. This indicates that our models can capture asymmetry—a symmetric model would either over-predict X–scientist-at–Y or under-predict person/company.

Conclusion

We present relation extraction into universal schemas. Such schemas contain surface patterns as relations, as well as relations from structured sources. By predicting missing tuples for surface pattern relations we can populate a database without any labelled data, and answer questions not supported by the structured schema alone. By predicting missing tuples in the structured schema we can expand a knowledge base of fixed schema, and only require a set of existing facts from this schema. Crucially , by predicting and modeling both surface patterns and structured relations simultaneously we can improve performance. We show this experimentally by contrasting a series of the popular weakly supervised models to our collaborative filtering models that learn latent feature representations across surface patterns and structured relations. Moreover, our models are computationally efficient, requiring less time than comparable methods, while learning more relations. Reasoning with universal schemas is not merely a tool for information extraction. It can also serve as a framework for various data integration tasks. For example, we could integrate facts from one schema (say, Freebase) into another (say, the TAC KBP schema) by adding both sets of relations to the set of surface patterns. Reasoning with this schema will mean populating each database with facts from the other, and would leverage information in surface patterns to improve integration. In future work we also plan to integrate universal entity types and attributes into the model. The source code of our system, its output, and all data annotations are available at http://www. riedelcastro.org/uschema.