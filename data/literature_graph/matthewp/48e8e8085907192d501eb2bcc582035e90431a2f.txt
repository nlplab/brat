Title: Multi-Task Cross-Lingual Sequence Tagging from Scratch

Abstract: We present a deep hierarchical recurrent neural network for sequence tagging. Given a sequence of words, our model employs deep gated recurrent units on both character and word levels to encode morphology and context information, and applies a conditional random field layer to predict the tags. Our model is task independent , language independent, and feature engineering free. We further extend our model to multi-task and cross-lingual joint training by sharing the architecture and parameters. Our model achieves state-of-the-art results in multiple languages on several benchmark tasks including POS tagging, chunking, and NER. We also demonstrate that multi-task and cross-lingual joint training can improve the performance in various cases.

Content: Introduction

Sequence tagging is a fundamental problem in natural language processing which has many wide applications, including part-of-speech (POS) tagging , chunking, and named entity recognition (NER). Given a sequence of words, sequence tagging aims to predict a linguistic tag for each word such as the POS tag. Recently progress has been made on neural sequence-tagging models which make only minimal assumptions about the language , task, and feature set (Collobert et al., 2011) This paper explores an important potential advantage of these task-independent, languageindependent and feature-engineering free models: their ability to be jointly trained on multiple tasks. In particular, we explore two types of joint training. In multi-task joint training, a model is jointly trained to perform multiple sequencetagging tasks in the same language—e.g., POS tagging and NER for English. In cross-lingual joint training, a model is trained to perform the same task in multiple languages—e.g., NER in English and Spanish. Multi-task joint training can exploit the fact that different sequence tagging tasks in one language share language-specific regularities. For example, models of English POS tagging and English NER might benefit from using similar underlying representations for words, and in past work, certain sequence-tagging tasks have benefitted by leveraging the underlying similarity of related tasks (Ando and Zhang, 2005). Currently, however, the best results on specific sequence-tagging tasks are usually achieved by approaches that target only one specific task, either POS tagging (Søgaard, 2011; Toutanova et al., 2003), chunking (Shen and Sarkar, 2005), or NER (Luo et al., 2015; Passos et al., 2014). Such approaches employ separate model development for each individual task, which makes joint training difficult. In other work, some recent neural approaches have been proposed to address multiple sequence tagging problems in a unified framework (Huang et al., 2015). Though gains have been shown using multi-task joint training, the prior models that benefit from multi-task joint training did not achieve state-ofthe-art performance (Collobert et al., 2011); thus the question of whether joint training can improve over strong baseline methods is still unresolved. Cross-lingual joint training typically uses word alignments or parallel corpora to improve the performance on different languages (Kiros et al., 2014; Gouws et al., 2014). However, many successful approaches in sequence tagging rely heavily on feature engineering to handcraft languagedependent features, such as character-level morphological features and word-level N-gram patterns (Huang et al., 2015; Toutanova et al., 2003; Sun et al., 2008), making it difficult to share latent representations between different languages. Some multilingual taggers that do not rely on feature engineering have also been presented (Lample et al., 2016; dos Santos et al., 2015), but while these methods are language-independent, they do not study the effect of cross-lingual joint training. In this work, we focus on developing a general model that can be applied in both multi-task and cross-lingual settings by learning from scratch, i.e., without feature engineering or pipelines. Given a sequence of words, our model employs deep gated recurrent units on both character and word levels, and applies a conditional random field layer to make the structured prediction. On the character level, the gated recurrent units capture the morphological information; on the word level, the gated recurrent units learn N-gram patterns and word semantics. Our model can handle both multi-task and cross-lingual joint training in a unified manner by simply sharing the network architecture and model parameters between tasks and languages. For multi-task joint training, we share both character and word level parameters between tasks to learn language-specific regularities. For crosslingual joint training, we share the character-level parameters to capture the morphological similarity between languages without use of parallel corpora or word alignments. We evaluate our model on five datasets of different tasks and languages, including POS tagging, chunking and NER in English; and NER in Dutch and Spanish. We achieve state-of-the-art results on several standard benchmarks: We also achieve very competitive results on Penn Treebank POS tagging (97.55%, the second best result in the literature). Finally, we conduct experiments to systematically explore the effectiveness of multi-task and cross-lingual joint training on several tasks.

Related Work

Ando and Zhang (2005) proposed a multi-task joint training framework that shares structural parameters among multiple tasks, and improved the performance on various tasks including NER. Collobert et al. (2011) presented a task independent convolutional network and employed multitask joint training to improve the performance of chunking. However, there is still a gap between these multi-task approaches and the state-of-theart results on individual tasks. Furthermore, it is unclear whether these approaches can be effective in a cross-lingual setting. Multilingual resources were extensively used for cross-lingual sequence tagging through various ways, such as cross-lingual feature extraction (Darwish, 2013), text categorization (Virga and Khudanpur, 2003), and Bayesian parallel data prediction (Snyder et al., 2008). Parallel corpora and word alignments are also used for training crosslingual distributed word representations (Kiros et al., 2014; Gouws et al., 2014; Zhou et al., 2015). Unlike these approaches, our method mainly focuses on using morphological similarity for crosslingual joint training. Several neural architectures based on recurrent networks were proposed for sequence tagging. Huang et al. (2015) ) employed convolutional layers on both character and word levels; Chiu and Nichols (2015) applied convolutional layers on the character level and LSTM units on the word level; Gillick et al. (2015) employed a sequence-to-sequence LSTM with a novel tagging scheme. We show that our architecture gives better performance experimentally than these approaches in Section 5. Most similar to our work is the recent approach independently developed by Lample et al. (2016) (published two weeks before our submission), which employs LSTM on both character and word levels. However, there are several crucial differences . First, we study cross-lingual joint training and show improvement over their approach in various cases. Second, while they mainly focus on NER, we generalize our model to other sequence tagging tasks, and also demonstrate the effectiveness of multi-task joint training. There are also differences in the technical aspect, such as the cost-sensitive loss function and gated recurrent units used in our work.

Model

In this section, we present our model for sequence tagging based on deep hierarchical gated recurrent units and conditional random fields. Our recurrent Figure 1: The architecture of

our

hierarchical GRU network with CRF, when L c = L w = 1 (only one layer for word-level and character-level GRUs respectively). We only display the character-level GRU for the word Mike and omit others. networks are hierarchical since we have multiple layers on both word and character levels in a hier- archy.

Gated Recurrent Unit

A gated recurrent unit (GRU) network is a type of recurrent neural networks first introduced for machine translation (Cho et al., 2014). A recurrent network can be represented as a sequence of units, corresponding to the input sequence (x 1 , x 2 , · · · , x T ), which can be either a word sequence in a sentence or a character sequence in a word. The unit at position t takes x t and the previous hidden state h t−1 as input, and outputs the current hidden state h t . The model parameters are shared between different units in the sequence. A gated recurrent unit at position t has two gates, an update gate z t and a reset gate r t . More specifically, each gated recurrent unit can be expressed as follows r t = σ(W rx x t + W rh h t−1 ) z t = σ(W zx x t + W zh h t−1 ) ˜ h t = tanh(W hx x t + W hh (r t h t−1 )) h t = z t h t−1 + (1 − z t ) ˜ h t , where W 's are model parameters of each unit, ˜ h t is a candidate hidden state that is used to compute h t , σ is an element-wise sigmoid logistic function defined as σ(x) = 1/(1 + e −x ), and denotes element-wise multiplication of two vectors. Intuitively , the update gate z t controls how much the unit updates its hidden state, and the reset gate r t determines how much information from the previous hidden state needs to be reset. Since a recurrent neural network only models the information flow in one direction, it is usually helpful to use an additional recurrent network that goes in the reverse direction. More specifically, we use bidirectional gated recurrent units, where given a sequence of length T , we have one GRU going from 1 to T and the other from T to 1. Let − → h t and ← − h t denote the hidden states at position t of the forward and backward GRUs respectively. We concatenate the two hidden states to form the final hidden state h t = [ − → h t , ← − h t ]. We stack multiple recurrent layers together to form a deep recurrent network (Sutskever et al., 2014). Each layer learns a more effective representation taking the hidden states of the previous layer as input. Let h l,t denote the hidden state at position t in layer l. The forward GRU at position t in layer l computes − → h l,t using − → h l,t−1 and h l−1,t as input, and the backward GRU performs similar operations but in a reverse direction.

Hierarchical GRU

Our model employs a hierarchical GRU that encodes both word-level and character-level sequential information. The input of our model is a sequence of words (x 1 , x 2 , · · · , x T ) of length T , where x t is a oneof-K embedding of the t-th word. The word at each position t also has a character-level representation , denoted as a sequence of length S t , (c t,1 , c t,2 , · · · , c t,St ) where c t,s is the one-of-K embedding of the s-th character in the t-th word. Given a word, we first employ a deep bidirectional GRU to learn useful morphological representation from the character sequence of the word. Suppose the character-level GRU has L c layers, we then obtain forward and backward hidden states ← − h L c ,s and − → h L c ,s at each position s in the character sequence . Since recurrent networks usually tend to memorize more short-term patterns, we concatenate the first hidden state of the backward GRU and the last hidden state of the forward GRU to encode character-level morphology in both prefixes and suffixes. We further concatenate the characterlevel representation with the one-of-K word embedding x t to form the final representation h w t for the t-th word. More specifically, we have h w t = [ − → h L c ,St , ← − h L c ,1 , x t ], where h w t is a representation of the t-th word, which encodes both character-level morphology and word-level semantics, as shown in Figure 1. 3.2.2 Word-Level GRU The character-level GRU outputs a sequence of word representations h w = (h w 1 , h w 2 , · · · , h w T ). We employ a word-level deep bidirectional GRU with L w layers on top of these word representations . The word-level GRU takes the sequence h w as input, and computes a sequence of hidden states h = (h 1 , h 2 , · · · , h T ). Different from the character-level GRU, the word-level GRU aims to extract the context information in the word sequence, such as N-gram patterns and neighbor word dependencies. Such information is usually encoded using handcrafted features. However, as we show in our experimental results, the word-level GRU can learn the relevant information without being language-specific or task-specific. The hidden states h output by the word-level GRU will be used as input features for the next layers.

Conditional Random Field

The goal of sequence tagging is to predict a sequence of tags y = (y 1 , y 2 , · · · , y T ). To model the dependencies between tags in a sequence, we apply a conditional random field (Lafferty et al., 2001) layer on top of the hidden states h output by the word-level GRU (Huang et al., 2015). Let Y(h) denote the space of tag sequences for h. The conditional log probability of a tag sequence y, given the hidden state sequence h, can be written as log p(y|h) = f (h, y) − log y ∈Y(h) exp f (h, y ), (1) where f is a function that assigns a score for each pair of h and y. To define the function f (h, y), for each position t, we multiply the hidden state h w t with a parameter vector w yt that is indexed by the the tag y t , to obtain the score for assigning y t at position t. Since we also need to consider the correlation between tags, we impose first order dependency by adding a score A y t−1 ,yt at position t, where A is a parameter matrix defining the similarity scores between different tag pairs. Formally, the function f can be written as f (h, y) = T t=1 w T yt h w t + T t=1 A y t−1 ,yt , where we set y 0 to be a START token. It is possible to directly maximize the conditional log likelihood based on Eq. (1). However, this training objective is usually not optimal since each possible y contributes equally to the objective function. Therefore, we add a cost function between y and y based on the max-margin principle that high-cost tags y should be penalized more heavily (Gimpel and Smith, 2010). More specifically , the objective function to maximize for each training instance y and h is written as f (h, y) − log y ∈Y(h) exp(f (h, y ) + cost(y, y )). (2) In our work, the cost function is defined as the tag-wise Hamming loss between two tag sequences multiplied by a constant. The objective function on the training set is the sum of Eq. (2) over all the training instances. The full architecture of our model is illustrated in Figure 1 .

Training

We employ mini-batch AdaGrad (Duchi et al., 2011) to train our neural network in an end-toend manner with backpropagation. Both the character embeddings and word embeddings are finetuned during training. We use dynamic programming to compute the normalizer of the CRF layer in Eq. (2). When making prediction, we again use dynamic programming in the CRF layer to decode the most probable tag sequence. Figure 2: Network architectures

for

multi-task and crosslingual joint training. Red boxes indicate shared architecture and parameters. Blue boxes are task/language specific components trained separately. Eng, Span, Char, and Emb refer to English, Spanish, Character and Embeddings.

Multi-Task and Cross-Lingual Joint Training

In this section we study joint training of multiple tasks and multiple languages. On one hand, different sequence tagging tasks in the same language share language-specific regularities. For example , POS tagging and NER in English should learn similar underlying representation since they are in the same language. On the other hand, some languages share character-level morphologies, such as English and Spanish. Therefore, it is desirable to leverage multi-task and cross-lingual joint training to boost model performance. Since our model is generally applicable to different tasks in different languages, it can be naturally extended to multi-task and cross-lingual joint training. The basic idea is to share part of the architecture and parameters between tasks and languages, and to jointly train multiple objective functions with respect to different tasks and lan- guages. We now discuss the details of our joint training algorithm in the multi-task setting. Suppose we have D tasks, with the training instances of each task being (X 1 , X 2 , · · · , X D ). Each task d has a set of model parameters W d , which is divided into two sets, task specific parameters and shared parameters , i.e., W d = W d,spec ∪ W shared , where shared parameters W shared are a set of parameters that are shared among the D tasks, while task specific parameters W d,spec are the rest of the parameters that are trained for each task d sepa- rately. During joint training, we are optimizing the average over all objective functions of D tasks. We iterate over each task d, sample a batch of training instances from X d , and perform a gradient descent step to update model parameters W d . Similarly, we can derive a cross-lingual joint training algorithm by replacing D tasks with D languages. The network architectures we employ for joint training are illustrated in Figure 2. For multi-task joint training, we share all the parameters below the CRF layer including word embeddings to learn language-specific regularities shared by the tasks. For cross-lingual joint training, we share the parameters of the character-level GRU to capture the morphological similarity between languages. Note that since we do not consider using parallel corpus in this work, we mainly focus on joint training between languages with similar morphology . We leave the study of cross-lingual joint training by sharing word semantics based on parallel corpora to future work.

Experiments

In this section, we use several benchmark datasets for multiple tasks in multiple languages to evaluate our model as well as the joint training algorithm.

Datasets and Settings

We use the following benchmark datasets in our experiments: Penn Treebank (PTB) POS tagging, CoNLL 2000 chunking, CoNLL 2003 English NER, CoNLL 2002 Dutch NER and CoNLL 2002 Spanish NER. The statistics of the datasets are described in Table 1. We construct the POS tagging dataset with the instructions described in Toutanova et al. (2003). Note that as a standard practice, the POS tags are extracted from the parsed trees. Table 1: Table 2: Comparison with state-of-the-art results on CoNLL 2003 English NER when trained with training set only. † means using handcrafted features. ‡ means being task-specific. For the task of CoNLL 2003 English NER, we follow previous works (Collobert et al., 2011; Huang et al., 2015; Chiu and Nichols, 2015) to append one-hot gazetteer features to the input of the CRF layer for fair comparison. 1 We set the hidden state dimensions to be 300 for the word-level GRU. We set the number of GRU layers to L c = L w = 2 (two layers for the wordlevel and character-level GRUs respectively). The learning rate is fixed at 0.01. We use the development set to tune the other hyperparameters of our model. Since the CoNLL 2000 chunking dataset does not have a development set, we hold out one fifth of the training set for parameter tuning. We truncate all words whose character sequence length is longer than a threshold (17 for English, 35 for Dutch, and 20 for Spanish). We replace all numeric characters with " 0 " . We also use the BIOES (Begin, Inside, Outside, End, Single) tagging scheme (Ratinov and Roth, 2009). 5.2 Pre-Trained Word Embeddings Since the training corpus for a sequence tagging task is relatively small, it is difficult to train ran- 1 Although gazetteers are arguably a type of feature engineering , we note that unlike most feature engineering techniques they are straightforward to include in a model. We use only the gazetteer file provided by the CoNLL 2003 shared task, and do not use gazetteers for any other tasks or languages described here. Table 3: Comparison with state-of-the-art results on CoNLL 2003 English NER when trained with both training and dev sets. † means using handcrafted features. ‡ means being task-specific. * means not using gazetteer lists. domly initialized word embeddings to accurately capture the word semantics. Therefore, we leverage word embeddings pre-trained on large-scale corpora. All the pre-trained embeddings we use are publicly available. On the English datasets, following previous works that are based on neural networks (Collobert et al., 2011; Huang et al., 2015; Chiu and Nichols, 2015), we use the 50-dimensional SENNA embeddings 2 trained on Wikipedia. For Spanish and Dutch, we use the 64-dimensional Polyglot embeddings 3 (Al-Rfou et al., 2013), which are trained on Wikipedia articles of the corresponding languages. We use pre-trained word embeddings as initialization, and fine-tune the embeddings during training.

Performance

In this section, we report the results of our model on the benchmark datasets and compare to the previously-reported state-of-the-art results. Table 4: Comparison with state-of-the-art results on For English NER, there are two evaluation methods used in the literature. Some models are trained with both the training and development set, while others are trained with the training set only. We report our results in both cases. In the first case, we tune the hyperparameters by training on the training set and testing on the development set. Besides our standalone model, we experimented with multi-task and cross-lingual joint training as well, using the architecture described in Section 4. For multi-task joint training, we jointly train all tasks in English, including POS tagging, chunking and NER. For cross-lingual joint training , we jointly train NER in English, Dutch and Spanish. We also remove the word embeddings and the character-level GRU respectively to analyze the contribution of different components. The results are shown in Tables 2, 3, 4, 5, 6 and 7. We achieve state-of-the-art results on English NER, Dutch NER, Spanish NER and English chunking. However, the embeddings they used are not publicly available. To demonstrate the effectiveness of our model, we slightly revise our model to reimplement their model with the same parameter settings described in their original paper. We use SENNA embeddings to initialize the reimplemented model for fair comparison, and obtain an accuracy of 97.41% that is 0.14 points worse than our result, which indicates that our model is more effective and the main difference lies in using different pre-trained embeddings. By comparing the results without the character- Table 7: Comparison with state-of-the-art results on PTB POS tagging. † means using handcrafted features. ‡ means being task-specific. * indicates our reimplementation (using SENNA embeddings). level GRU and without word embeddings, we can observe that both components contribute to the final results. It is also clear that word embeddings have significantly more contribution than the character-level GRU, which indicates that our model largely depends on memorizing the word semantics. Character-level morphology, on the other hand, has relatively smaller but still critical contribution.

Joint Training

In this section, we analyze the effectiveness of multi-task and cross-lingual joint training in more detail. In order to explore possible gains in performance of joint training for resource-poor languages or tasks, we consider joint training of various task pairs and language pairs where differentsized subsets of the actual labeled corpora are made available. Given a pair of tasks of languages, we jointly train one task with full labels and the other with partial labels. In particular, we introduce a labeling rate r, and sample a fraction r of the sentences in the training set, discarding the rest. Evaluation is based on the partially-labeled task. The results are reported in Table 8. We observe that the performance of a specific task with relatively lower labeling rates (0.1 and 0.3) can usually benefit from other tasks with full labels through multi-task or cross-lingual joint training. The performance gain can be up to 1.99 points when the labeling rate of the target task is 0.1. The improvement with 0.1 labeling rate is on average 0.37 points larger than with 0.3 labeling rate, which indicates that the improvement of joint training is more significant when the target Table 8: Multi-task and cross-lingual joint training. We compare the results obtained by a standalone model and joint training with another task or language. The number following a task is the labeling rate (0.1 or 0.3). Eng and NER both refer to English NER, Span means Spanish. In the column titles, Task is the target task, J. Task is the jointly-trained task with full labels, Sep. is the F1/Accuracy of the target task trained separately, Joint is the F1/Accuracy of the target task with joint training, and Delta is the improvement. task has less labeled data. We also use t-SNE (Van der Maaten and Hinton , 2008) to obtain a 2-dimensional visualization of the character-level GRU output for the country names in English and Spanish, shown in Figure 3. We can clearly see that our model captures the morphological similarity between two languages through joint training, since all corresponding pairs are nearest neighbors in the original embedding space.

Conclusion

We presented a new model for sequence tagging based on gated recurrent units and conditional random fields. We explored multi-task and crosslingual joint training through sharing part of the network architecture and model parameters. We achieved state-of-the-art results on various tasks including POS tagging, chunking, and NER, in multiple languages. We also demonstrated that joint training can improve model performance in various cases. In this work, we mainly focus on leveraging morphological similarities for cross-lingual joint training. In the future, an important problem will be joint training based on cross-lingual word semantics with the help of parallel data. Furthermore , it will be interesting to apply our joint training approach to low-resource tasks and lan- guages.