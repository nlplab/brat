Title: A Knowledge Compilation Map

Abstract: We propose a perspective on knowledge compilation which calls for analyzing different compilation approaches according to two key dimensions: the succinctness of the target compilation language, and the class of queries and transformations that the language supports in polytime. We then provide a knowledge compilation map, which analyzes a large number of existing target compilation languages according to their succinctness and their polytime transformations and queries. We argue that such analysis is necessary for placing new compilation approaches within the context of existing ones. We also go beyond classical, flat target compilation languages based on CNF and DNF, and consider a richer, nested class based on directed acyclic graphs (such as OBDDs), which we show to include a relatively large number of target compilation languages.

Content: Introduction

Knowledge compilation has emerged recently as a key direction of research for dealing with the computational intractability of general propositional reasoning (Darwiche, 1999; Cadoli & Donini, 1997; Boufkhad, Grégoire, Marquis, Mazure, & Sa¨ıs, 1997; Khardon & Roth, 1997; Selman & Kautz, 1996; Schrag, 1996; Marquis, 1995; del Val, 1994; Dechter & Rish, 1994; Reiter & de Kleer, 1987). According to this direction, a propositional theory is compiled off-line into a target language, which is then used on-line to answer a large number of queries in polytime. The key motivation behind knowledge compilation is to push as much of the computational overhead into the off-line phase, which is amortized over all on-line queries. But knowledge compilation can serve other important purposes as well. For example, target compilation languages and their associated algorithms can be very simple, allowing one to develop on-line reasoning systems for simple software and hardware platforms. Moreover, the simplicity of algorithms that operate on compiled languages help in streamlining the effort of algorithmic design into a single task: that of generating the smallest compiled representations possible, as that turns out to be the main computational bottleneck in compilation approaches. There are three key aspects of any knowledge compilation approach: the succinctness of the target language into which the propositional theory is compiled; the class of queries that can be answered in polytime based on the compiled representation; and the class of transformations that can be applied to the representation in polytime. The AI literature has thus far focused mostly on target compilation languages which are variations on DNF and CNF formulas, such as Horn theories and prime implicates. Moreover, it has focused mostly on clausal entailment queries, with very little discussion of tractable transformations on compiled theories. The goal of this paper is to provide a broad perspective on knowledge compilation by considering a relatively large number of target compilation languages and analyzing them according to their succinctness and the class of queries/transformations that they admit in polytime.

Darwiche & Marquis

Instead of focusing on classical, flat target compilation languages based on CNF and DNF, we consider a richer, nested class based on representing propositional sentences using directed acyclic graphs, which we refer to as NNF. We identify a number of target compilation languages that have been presented in the AI, formal verification, and computer science literature and show that they are special cases of NNF. For each such class, we list the extra conditions that need to be imposed on NNF to obtain the specific class, and then identify the set of queries and transformations that the class supports in polytime. We also provide cross-rankings of the different subsets of NNF, according to their succinctness and the polytime operations they support. The main contribution of this paper is then a map for deciding the target compilation language that is most suitable for a particular application. Specifically, we propose that one starts by identifying the set of queries and transformations needed for their given application, and then choosing the most succinct language that supports these operations in polytime. This paper is structured as follows. We start by formally defining the NNF language in Section 2, where we list a number of conditions on NNF that give rise to a variety of target compilation languages. We then study the succinctness of these languages in Section 3 and provide a cross-ranking that compares them according to this measure. We consider a number of queries and their applications in Section 4 and compare the different target compilation languages according to their tractability with respect to these queries. Section 5 is then dedicated to a class of transformations, their applications, and their tractability with respect to the different target compilation languages. We finally close in Section 6 by some concluding remarks. Proofs of all theorems are delegated to Appendix A.

The NNF Language

We consider more than a dozen languages in this paper, all of which are subsets of the NNF language, which is defined formally as follows (Darwiche, 1999, 2001a). Figure 1 depicts a sentence in NNF, which represents the odd parity function (we omit reference to variables PS when no confusion is anticipated). Any propositional sentence can be represented as a sentence in NNF, so the NNF language is complete. It is important here to distinguish between a representation language and a target compilation language. A representation language is one which we expect humans to read and write with some ease. The language of CNF is a popular representation language, and so is the language of Horn clauses (especially when expressed in rules form). On other hand, a target compilation language does not need to be suitable for human specification and interpretation, but should be tractable enough to permit a non-trivial number of polytime queries and/or transformations. We will consider a number of target compilation languages that do not qualify as representation languages from this perspective, as they are not suitable for humans to construct or interpret. We will also consider a number of representation languages that do not qualify as target compilation languages.

1

A formal characterization of representation languages is outside the scope of this paper. But for a language to qualify as a target compilation language, we will require that it permits a polytime clausal entailment test. Note that a polytime consistency test is not sufficient here, as only one consistency test on a given theory does not justify its compilation. Given this definition, NNF does A Knowledge Compilation Map

Decomposability

¬ ¬A B ¬ ¬ B A C ¬ ¬ D D ¬ ¬ C

and and and and and and and and or or or or and and or

A,B C,D (a)

Determinism

¬ ¬A B ¬ ¬ B A C ¬ ¬ D D ¬ ¬ C

and and and and and and and and or or or or and and or

(b)

Smoothness

¬ ¬A B ¬ ¬ B A C ¬ ¬ D D ¬ ¬ C

and and and and and and and and or or or or and and or A,B

A,B (c) Figure 1: A sentence in NNF. Its size is 30 and height is 4. not qualify as a target compilation language unless P=NP (Papadimitriou, 1994), but many of its subsets do. We define a number of these subsets below, each of which is obtained by imposing further conditions on NNF. We will distinguish between two key subsets of NNF: flat and nested subsets. We first consider flat subsets, which result from imposing combinations of the following properties: • Flatness: The height of each sentence is at most 2. The sentence in Figure 3 is flat, but the one in Figure 1 is not.

•

Simple-disjunction: The children of each or-node are leaves that share no variables (the node is a clause).

•

Simple-conjunction: The children of each and-node are leaves that share no variables (the node is a term). The sentence in Figure 3 satisfies this property. Definition 2 .

2

The language f-NNF is the subset of NNF satisfying flatness. The language CNF is the subset of f-NNF satisfying simple–disjunction. The language DNF is the subset of f-NNF satisfying simple–conjunction. CNF does not permit a polytime clausal entailment test (unless P=NP) and, hence, does not qualify as a target compilation language. But its dual DNF does. The following subset of CNF, prime implicates, has been quite influential in computer science: Definition 2.3 The language PI is the subset of CNF in which each clause entailed by the sentence is subsumed by a clause that appears in the sentence; and no clause in the sentence is subsumed by another. A dual of PI, prime implicants IP, can also be defined. Definition 2.4 The language IP is the subset of DNF in which each term entailing the sentence subsumes some term that appears in the sentence; and no term in the sentence is subsumed by another term. There has been some work on representing the set of prime implicates of a propositional theory in a compact way, allowing an exponential number of prime implicates to be represented in polynomial space in certain cases—see for example the TRIE representation in (de Kleer, 1992), the ZBDD representation used in (Simon & del Val, 2001), and the implicit representation based on metaproducts , as proposed in (Madre & Coudert, 1992). These representations are different from the language PI in the sense that they do not necessarily support the same queries and transformations that we report in Tables 5 and 7. They also exhibit different succinctness relationships than the ones we report in Table 3. Horn theories (and renamable Horn theories) represent another target compilation subset of CNF, but we do not consider it here since we restrict our attention to complete languages L only, i.e., we require that every propositional sentence is logically equivalent to an element of L. We now consider nested subsets of the NNF language, which do not impose any restriction on the height of a sentence. Instead, these subsets result from imposing one or more of the following conditions: decomposability, determinism, smoothness, decision, and ordering. We start by defining the first three properties. From here on, if C is a node in an NNF, then Vars(C) denotes the set of all variables that label the descendants of node C. Moreover, if Σ is an NNF sentence rooted at C, then Vars(Σ) is defined as Vars(C).

•

Decomposability (Darwiche, 1999, 2001a). An NNF satisfies this property if for each conjunction C in the NNF, the conjuncts of C do not share variables. That is, if C 1 , . . . , C n are the children of and-node C, then Vars(C i ) ∩ Vars(C j ) = ∅ for i = j. Consider the and-node marked in Figure 1(a). This node has two children, the first contains variables A, B while the second contains variables C, D. This and-node is then decomposable since the two children do not share variables. Each other and-node in Figure 1(a) is also decomposable and, hence, the NNF in this figure is decomposable.

•

Determinism (Darwiche, 2001b): An NNF satisfies this property if for each disjunction C in the NNF, each two disjuncts of C are logically contradictory. That is, if C 1 , . . . , C n are the children of or-node C, then C i ∧ C j |= false for i = j. Consider the or-node marked in Figure 1(b), which has two children corresponding to sub-sentences ¬A ∧ B and ¬B ∧ A. The conjunction of these two sub-sentences is logically contradictory. The or-node is then deterministic and so are the other or-nodes in Figure 1(b). Hence, the NNF in this figure is deterministic.

•

Smoothness (Darwiche, 2001b): An NNF satisfies this property if for each disjunction C in the NNF, each disjunct of C mentions the same variables. That is, if C 1 , . . . , C n are the children of or-node C, then Vars(C i ) = Vars(C j ) for i = j. Consider the marked or-node in Figure 1(c). This node has two children, each of which mentions variables A, B. This or-node is then smooth and so are the other or-nodes in Figure 1(c). Hence, the NNF in this figure is smooth. It is hard to ensure decomposability. It is also hard to ensure determinism while preserving decomposability . Yet any sentence in NNF can be smoothed in polytime, while preserving decomposability and determinism. Preserving flatness, however, may blow-up the size of given NNF. Hence, smoothness is not that important from a complexity viewpoint unless we have flatness. The properties of decomposability, determinism and smoothness lead to a number of interesting subsets of NNF. Definition 2.5 The language DNNF is the subset of NNF satisfying decomposability; d-NNF is the subset satisfying determinism; s-NNF is the subset satisfying smoothness; d-DNNF is the subset satisfying decomposability and determinism; and sd-DNNF is the subset satisfying decomposability, determinism and smoothness. Note that DNF is a strict subset of DNNF (Darwiche, 1999, 2001a). The following decision property comes from the literature on binary decision diagrams (Bryant, 1986). Definition 2.6 (Decision) A decision node N in an NNF sentence is one which is labeled with true, false, or is an or-node having the form (X ∧ α) ∨ (¬X ∧ β), where X is a variable, α and β are decision nodes. In the latter case, dVar (N ) denotes the variable X. Definition 2.7 The language BDD is the set of NNF sentences, where the root of each sentence is a decision node.

or and and X1 ¬ ¬ X1 or or and and and and X2 X2

¬ ¬ X2 ¬ ¬ X2

and and and and X3 X3

¬ ¬ X3 ¬ ¬ X3 or or true false X1 X2 X2 X3 X3

0

Figure 2: On the left, a sentence in the BDD language. On the right, its corresponding binary decision diagram. The NNF sentence in Figure 2 belongs to the BDD subset. The BDD language corresponds to binary decision diagrams (BDDs), as known in the formal verification literature (Bryant, 1986). Binary decision diagrams are depicted using a more compact notation though: the labels true and false are denoted by 1 and 0, respectively; and each decision node X ¬ ¬X α β and or and is denoted by α β X . The BDD sentence on the left of Figure 2 corresponds to the binary decision diagram on the right of Figure 2. Obviously enough, every NNF sentence that satisfies the decision property is also deterministic. Therefore, BDD is a subset of d-NNF. As we show later, BDD does not qualify as a target compilation language (unless P=NP), but the following subset does. Definition 2.8 FBDD is the intersection of DNNF and BDD. That is, each sentence in FBDD is decomposable and satisfies the decision property. The FBDD language corresponds to free binary decision diagrams (FBDDs), as known in formal verification (Gergov & Meinel, 1994a). An FBDD is usually defined as a BDD that satisfies the read-once property: on each path from the root to a leaf, a variable can appear at most once. FBDDs are also known as read-once branching programs in the theory literature. Imposing the read-once property on a BDD is equivalent to imposing the decomposability property on its corresponding BDD sentence. A more influential subset of the BDD language is obtained by imposing the ordering property: The language OBDD is the union of all OBDD < languages. The OBDD language corresponds to the well–known ordered binary decision diagrams (OBDDs) (Bryant, 1986). Our final language definition is as follows: Definition 2.11 MODS is the subset of DNF where every sentence satisfies determinism and smooth- ness. Darwiche & Marquis ¬ ¬X X ¬ ¬Y Y ¬ ¬Z

Z and or and and and

Figure 3: A sentence in language MODS. NNF d-NNF s-NNF f-NNF sd-DNNF DNNF CO, CE, ME d-DNNF VA, IM, CT EQ? CNF DNF IP PI CO , CE, EQ, SE, ME VA, IM, EQ, SE BDD FBDD EQ? OBDD < SE MODS EQ, SE VA, IM

OBDD EQ

Figure 4: The set of DAG-based languages considered in this paper. An edge L 1 → L 2 means that L 1 is a proper subset of L 2 . Next to each subset, we list the polytime queries supported by the subset but not by any of its ancestors (see Section 4). Figure 3 depicts a sentence in MODS. As we show later, MODS is the most tractable NNF subset we shall consider (together with OBDD < ). This is not surprising since from the syntax of a sentence in MODS, one can immediately recover the sentence models. The languages we have discussed so far are depicted in Figure 4, where arrows denote set inclusion. Table 1 lists the acronyms of all of these languages, together with their descriptions. Table 2 lists the key language properties discussed in this section, together with a short description of each.

3

. On the Succinctness of Compiled Theories We have discussed more than a dozen subsets of the NNF language. Some of these subsets are well known and have been studied extensively in the computer science literature. Others, such as DNNF (Darwiche, 2001a, 1999) and d-DNNF (Darwiche, 2001b), are relatively new. The question now is: What subset should one adopt for a particular application? As we argue in this paper, that depends Acronym Description NNF Negation Normal Form DNNF Decomposable Negation Normal Form d-NNF Deterministic Negation Normal Form s-NNF Smooth Negation Normal Form f-NNF Flat Negation Normal Form d-DNNF Deterministic Decomposable Negation Normal Form sd-DNNF Every disjunction is a clause, where literals share no variables Simple Conjunction Every conjunction is a term, where literals share no variables Decomposability Conjuncts do not share variables Determinism Disjuncts are logically disjoint Smoothness Disjuncts mention the same set of variables Decision A node of the form true, false, or (X ∧ α ∨ ¬X ∧ β), where X is a variable and α, β are decision nodes Ordering Decision variables appear in the same order on any path in the NNF Table 2: Language properties. on three key properties of the language: its succinctness, the class of tractable queries it supports, and the class of tractable transformations it admits. Our goal in this and the following sections is to construct a map on which we place different subsets of the NNF language according to the above criteria. This map will then serve as a guide to system designers in choosing the target compilation language most suitable to their application. It also provides an example paradigm for studying and evaluating further target compilation languages. We start with a study of succinctness 2 in this section (Gogic, Kautz, Papadimitriou, & Selman, 1995). Definition 3.1 (Succinctness) Let L 1 and L 2 be two subsets of NNF. L 1 is at least as succinct as L 2 , denoted L 1 ≤ L 2 , iff there exists a polynomial p such that for every sentence α ∈ L 2 , there exists an equivalent sentence β ∈ L 1 where |β| ≤ p(|α|). Here, |α| and |β| are the sizes of α and β, respectively. We stress here that we do not require that there exists a function that computes β given α in polytime; we only require that a polysize β exists. Yet, our proofs in Appendix A contain specific algorithms for computing β from α in certain cases. The relation ≤ is clearly reflexive and transitive, hence, a pre-ordering. One can also define the relation <, where L 1 < L 2 iff L 1 ≤ L 2 and L 2 ≤ L 1 . Proposition 3.1 The results in Table 3 hold. An occurrence of ≤ in the cell of row r and column c of Table 3 means that the fragment L r given at row r is at least as succinct as the fragment L c given at column c. An occurrence of ≤ (or ≤ * ) means that L r is not at least as succinct as L c (provided that the polynomial hierarchy does not collapse in the case of ≤ * ). Finally, the presence of a question mark reflects our ignorance about whether L r is at least as succinct as L c . Figure 5 summarizes the results of Proposition 3.1 in terms of a directed acyclic graph. A classical result in knowledge compilation states that it is not possible to compile any propositional formula α into a polysize data structure β such that: α and β entail the same set of clauses, and clausal entailment on β can be decided in time polynomial in its size, unless NP ⊆ P/poly (Selman & Kautz, 1996; Cadoli & Donini, 1997). This last assumption implies the collapse of the polynomial hierarchy at the second level (Karp & Lipton, 1980), which is considered very unlikely. We use this classical result from knowledge compilation in some of our proofs of Proposition 3.1, which explains why some of its parts are conditioned on the polynomial hierarchy not collapsing. We have excluded the subsets BDD, s-NNF, d-NNF and f-NNF from Table 3 since they do not qualify as target compilation languages (see Section 4). We kept NNF and CNF though given their importance. Consider Figure 5 which depicts Table 3 graphically. With the exception of NNF and CNF, all other languages depicted in Figure 5 qualify as target compilation languages. Moreover, with the exception of language PI, DNNF is the most succinct among all target compilation languages—we know that PI is not more succinct than DNNF, but we do not know whether DNNF is more succinct than PI. In between DNNF and MODS, there is a succinctness ordering of target compilation languages: DNNF < d-DNNF < FBDD < OBDD < OBDD < < MODS. DNNF is obtained by imposing decomposability on NNF; d-DNNF by adding determinism; FBDD by adding decision; and OBDD and OBDD < by adding ordering (w.r.t. any total ordering on PS in the first case and a specific one in the second case). Adding each of these properties reduces language succinctness (assuming that the polynomial hierarchy does not collapse). One important fact to stress here is that adding smoothness to d-DNNF does not affect its succinctness: the sd-DNNF and d-DNNF languages are equally succinct. It is also interesting to compare Table 3: Succinctness of target compilation languages. * means that the result holds unless the polynomial hierarchy collapses. NNF DNNF CNF d-DNNF DNF PI FBDD OBDD < IP MODS sd-DNNF =

OBDD

Figure 5: An edge L 1 → L 2 indicates that L 1 is strictly more succinct than L 2 : L 1 < L 2 , while L 1 = L 2 indicates that L 1 and L 2 are equally succinct: L 1 ≤ L 2 and L 2 ≤ L 1 . Dotted arrows indicate unknown relationships; for instance, the dotted arrow from DNNF to PI means that we do not know whether DNNF is at least as succinct as PI. Some of the edges are conditioned on the polynomial hierarchy not collapsing—see Table 3 . sd-DNNF (which is more succinct than the influential FBDD, OBDD and OBDD < languages) with MODS, which is a most tractable language. Both sd-DNNF and MODS are smooth, deterministic and decomposable . MODS, however, is flat and obtains its decomposability from the stronger condition of simple-conjunction. Therefore, sd-DNNF can be viewed as the result of relaxing from MODS the flatness and simple-conjunction conditions, while maintaining decomposability, determinism and smoothness. Relaxing these conditions moves the language three levels up the succinctness hierarchy , although it compromises only the polytime test for sentential entailment and possibly the one for equivalence as we show in Section 4.

Querying a Compiled Theory

In evaluating the suitability of a target compilation language to a particular application, the succinctness of the language must be balanced against the set of queries and transformations that it supports in polytime. We consider in this section a number of queries, each of which returns valuable information about a propositional theory, and then identify target compilation languages which provide polytime algorithms for answering such queries. We restrict our attention in this paper to the existence of polytime algorithms for answering queries, but we do not present the algorithms themselves. The interested reader is referred to (Darwiche, 2001a, 2001b, 1999; Bryant, 1986) for some of these algorithms and to the proofs of theorems in Appendix A for others. The queries we consider are tests for consistency, validity, implicates (clausal entailment), implicants , equivalence, and sentential entailment. We also consider counting and enumerating theory models; see Table 4. One can also consider computing the probability of a propositional sentence, assuming that all variables are probabilistically independent. For the subsets we consider, however, this can be done in polytime whenever models can be counted in polytime. From here on, L denotes a subset of language NNF. One of the main applications of compiling a theory is to enhance the efficiency of answering clausal entailment queries: Definition 4.2 (CE) L satisfies CE iff there exists a polytime algorithm that maps every formula Σ from L and every clause γ from NNF to 1 if Σ |= γ holds, and to 0 otherwise. A key application of clausal entailment is in testing equivalence. Specifically, suppose we have a design expressed as a set of clauses ∆ d = i α i and a specification expressed also as a set of clauses ∆ s = j β j , and we want to test whether the design and specification are equivalent. By compiling each of ∆ d and ∆ s to targets Γ d and Γ s that support a polytime clausal entailment test, we can test the equivalence of ∆ d and ∆ s in polytime. That is, ∆ d and ∆ s are equivalent iff Γ d |= β j for all j and Γ s |= α i for all i. A number of the target compilation languages we shall consider support a direct polytime equivalent test: Note that sentential entailment (SE) is stronger than clausal entailment and equivalence. Therefore, if a language L satisfies SE, it also satisfies CE and EQ. For completeness, we consider the following dual to CE: Definition 4.4 (IM) L satisfies IM iff there exists a polytime algorithm that maps every formula Σ from L and every term γ from NNF to 1 if γ |= Σ holds, and to 0 otherwise. Finally, we consider counting and enumerating models: where n is the size of Σ and m is the number of its models (over variables occurring in Σ).

Notation

Query CO polytime consistency check VA polytime validity check CE polytime clausal entailment check IM polytime implicant check EQ polytime equivalence check SE polytime sentential entailment check CT polytime model counting ME polytime model enumeration Table 4: Notations for queries. Table 5: Subsets of the NNF language and their corresponding polytime queries. √ means " satisfies " and • means " does not satisfy unless P = NP. " Table 4 summarizes the queries we are interested in and their acronyms. The following proposition states what we know about the availability of polytime algorithms for answering the above queries, with respect to all languages we introduced in Section 2. Proposition 4.1 The results in Table 5 hold. The results of Proposition 4.1 are summarized in Figure 4 . One can draw a number of conclusions based on the results in this figure. First, NNF, s-NNF, d-NNF, f-NNF, and BDD fall in one equivalence class that does not support any polytime queries and CNF satisfies only VA and IM; hence, none of them qualifies as a target compilation language in this case. But the remaining languages all support polytime tests for consistency and clausal entailment. Therefore, simply imposing either of smoothness (s-NNF), determinism (d-NNF), flatness (f-NNF), or decision (BDD) on the NNF language does not lead to tractability with respect to any of the queries we consider—neither of these properties seem to be significant in isolation. Decomposability (DNNF), however, is an exception and leads immediately to polytime tests for both consistency and clausal entailment, and to a polytime algorithm for model enumeration. Recall the succinctness ordering DNNF < d-DNNF < FBDD < OBDD < OBDD < < MODS from Figure 5. By adding decomposability (DNNF), we obtain polytime tests for consistency and clausal entailment, in addition to a polytime model enumeration algorithm. By adding determinism to decomposability (d-DNNF), we obtain polytime tests for validity, implicant and model counting, which are quite significant. It is not clear, however, whether the combination of decomposability and determinism leads to a polytime test for equivalence. Moreover, adding the decision property on top of decomposability and determinism (FBDD) does not appear to increase tractability with respect to the given queries 3 , although it does lead to reducing language succinctness as shown in Figure 5. On the other hand, adding the ordering property on top of decomposability, determinism and decision, leads to polytime tests for equivalence (OBDD and OBDD < ) as well as sentential entailment provided that the ordering < is fixed (OBDD < ). As for the succinctness ordering NNF < DNNF < DNF < IP < MODS from Figure 5, note that DNNF is obtained by imposing decomposability on NNF, while DNF is obtained by imposing flatness and simple-conjunction (which is stronger than decomposability). What is interesting is that DNF is less succinct than DNNF, yet does not support any more polytime queries; see Figure 4. However, the addition of smoothness (and determinism) on top of flatness and simple-conjunction (MODS) leads to five additional polytime queries, including equivalence and entailment tests.

4

We close this section by noting that determinism appears to be necessary (but not sufficient) for polytime model counting: only deterministic languages, d-DNNF, sd-DNNF, FBDD, OBDD, OBDD < and MODS, support polytime counting. Moreover, polytime counting implies a polytime test of validity, but the opposite is not true.

Transforming a Compiled Theory

A query is an operation that returns information about a theory without changing it. A transformation , on the other hand, is an operation that returns a modified theory, which is then operated on using queries. Many applications require a combination of transformations and queries. If a language satisfies one of the above properties, we will say that it is closed under the corresponding operator. Closure under logical connectives is important for two key reasons. First, it has implications on how compilers are constructed for a given target language. For example, if a clause can be easily compiled into some language L, then closure under conjunction implies that compiling a CNF sentence into L is easy. Second, it has implications on the class of polytime queries supported by the target language: If a language L satisfies CO and is closed under negation and conjunction, then it must satisfy SE (to test whether ∆ |= Γ, all we have to do, by the Refutation Theorem, is test whether ∆ ∧ ¬Γ is inconsistent). Similarly, if a language satisfies VA and is closed under negation and disjunction, it must satisfy SE by the Deduction Theorem.

3.

Deciding the equivalence of two sentences in FBDD, d-DNNF, or in sd-DNNF, can be easily shown to be in coNP. However, we do not have a proof of coNP-hardness, nor do we have deterministic polytime algorithms for deciding these problems. Actually, the latter case is quite unlikely as the equivalence problem for FBDD has been intensively studied, with no such algorithm in sight. Note, however, that the equivalence of two sentences in FBDD can be decided probabilistically in polytime (Blum, Chandra, & Wegman, 1980), and similarly for sentences in d-DNNF (Darwiche & Huang, 2002). 4. Given flatness, simple-conjunction and smoothness, we can obtain determinism by simply removing duplicated terms. It is important to stress here that some languages are closed under a logical operator, only if the number of operands is bounded by a constant. We will refer to this as bounded closure. Conditioning has a number of applications, and corresponds to restriction in the literature on Boolean functions. The main application of conditioning is due to a theorem, which says that Σ ∧ γ is consistent iff Σ | γ is consistent (Darwiche, 2001a, 1999). Therefore, if a language satisfies CO and CD, then it must also satisfy CE. Conditioning also plays a key role in building compilers that enforce decomposability. If two sentences ∆ 1 and ∆ 2 are both decomposable (belong to DNNF), their conjunction ∆ 1 ∧ ∆ 2 is not necessarily decomposable since the sentences may share variables. Conditioning can be used to ensure decomposability in this case since ∆ 1 ∧ ∆ 2 is equivalent to The previous proposition is indeed a generalization to multiple variables of the well-known Shannon expansion in the literature on Boolean functions. It is also the basis for compiling CNF into DNNF (Darwiche, 1999, 2001a). Another critical transformation we shall consider is that of forgetting (also referred to as marginalization , or elimination of middle terms (Boole, 1854)): Therefore, to forget variables from X is to remove any reference to X from Σ, while maintaining all information that Σ captures about the complement of X. Note that ∃X.Σ is unique up to logical equivalence. Forgetting is an important transformation as it allows us to focus/project a theory on a set of variables. For example, if we know that some variables X will never appear in entailment queries, we can forget these variables from the compiled theory while maintaining its ability to answer such queries correctly. Another application of forgetting is in counting/enumerating the instantiations of some variables Y, which are consistent with a theory ∆. This query can be answered by counting/enumerating the models of ∃X.∆, where X is the complement of Y. Forgetting also has applications to planning, diagnosis and belief revision. For instance, in the SATPLAN framework, Table 7: Subsets of the NNF language and their polytime transformations. √ means " satisfies, " • means " does not satisfy, " while • means " does not satisfy unless P=NP. " compiling away fluents or actions amounts to forgetting variables. In model-based diagnosis, compiling away every variable except the abnormality ones does not remove any piece of information required to compute the conflicts and the diagnoses of a system (Darwiche, 2001a). Forgetting has also been used to design update operators with valuable properties (Herzig & Rifi, 1999). Table 6 summarizes the transformations we are interested in and their acronyms. The following proposition states what we know about the tractability of these transformations with respect to the identified target compilation languages. One can draw a number of observations regarding Table 7. First, all languages we consider satisfy CD and, hence, lend themselves to efficient application of the conditioning transformation. As for forgetting multiple variables, only DNNF, DNF, PI and MODS permit that in polytime. It is important to stress here that none of FBDD, OBDD and OBDD < permits polytime forgetting of multiple variables. This is noticeable since some of the recent applications of OBDD < to planning—within the so-called symbolic model checking approach to planning (A. Cimmati & Traverso, 1997)—depend crucially on the operation of forgetting and it may be more suitable to use a language that satisfies FO in this case. Note, however, that OBDD and OBDD < allow the forgetting of a single variable in polytime, but FBDD does not allow even that. d-DNNF is similar to FBDD as it satisfies neither FO nor SFO. It is also interesting to observe that none of the target compilation languages is closed under conjunction. A number of them, however, are closed under bounded conjunction, including OBDD < , DNF, IP and MODS. As for disjunction, the only target compilation languages that are closed under disjunction are DNNF and DNF. The OBDD < and PI languages, however, are closed under bounded disjunction. Again, the d-DNNF, FBDD and OBDD languages are closed under neither. The only target compilation languages that are closed under negation are FBDD, OBDD and OBDD < , while it is not known whether d-DNNF or sd-DNNF are closed under this operation. Note that d-DNNF and FBDD support the same set of polytime queries (equivalence checking is unknown for both) so they are indistinguishable from that viewpoint. Moreover, the only difference between the two languages in Table 7 is the closure of FBDD under negation, which does not seem to be that significant in light of no closure under either conjunction or disjunction. Note, however, that d-DNNF is more succinct than FBDD as given in Figure 5. Finally, OBDD < is the only target compilation language that is closed under negation, bounded conjunction, and bounded disjunction. This closure actually plays an important role in compiling propositional theories into OBDD < and is the basis of state-of-the-art compilers for this purpose (Bryant, 1986).

Conclusion

The main contribution of this paper is a methodology for analyzing propositional compilation approaches according to two key dimensions: the succinctness of the target compilation language, and the class of queries and transformations it supports in polytime. The second main contribution of the paper is a comprehensive analysis, according to the proposed methodology, of more than a dozen languages for which we have produced a knowledge compilation map, which cross-ranks these languages according to their succinctness, and the polytime queries and transformations they support. This map allows system designers to make informed decisions on which target compilation language to use: after the class of queries/transformations have been decided based on the application of interest, the designer chooses the most succinct target compilation language that supports such operations in polytime. Another key contribution of this paper is the uniform treatment we have applied to diverse target compilation languages, showing how they all are subsets of the NNF language. Specifically, we have identified a number of simple, yet meaningful, properties, including decomposability, determinism, decision and flatness, and showed how combinations of these properties give rise to different target compilation languages. The studied subsets include some well known languages such as PI, which has been influential in AI; OBDD < , which has been influential in formal verification; and CNF and DNF, which have been quite influential in computer science. The subsets also include some relatively new languages such as DNNF and d-DNNF, which appear to represent interesting, new balances between language succinctness and query/transformation tractability.

Acknowledgments

This is a revised and extended version of the paper " A Perspective on Knowledge Compilation, " in Proceedings of the 17 th International Joint Conference on Artificial Intelligence (IJCAI'01), pp. 175-182, 2001. We wish to thank Alvaro del Val, Mark Hopkins, Jérôme Lang and the anonymous reviewers for some suggestions and comments, as well as Ingo Wegener for his help with some of the issues discussed in the paper. This work has been done while the second author was a visiting researcher with the Computer Science Department at UCLA. The first author has been partly supported by NSF grant IIS-9988543 and MURI grant N00014-00-1-0617. The second author has been partly supported by the IUT de Lens, the Université d'Artois, the Nord/Pas-de-Calais Région under the TACT-TIC project, and by the European Community FEDER Program.

Appendix A. Proofs

To simplify the proofs of our main propositions later on, we have identified a number of lemmas that we list below. Some of the proofs of these lemmas are direct, but we include them for completeness. Then Σ s is equivalent to Σ and is smooth. Moreover, Σ s can be computed in time polynomial in the size of Σ and it satisfies decomposability and determinism. Proof: Let Σ be a sentence in FBDD and let α be a node in Σ. We can always replace α with (Y ∧α)∨ (¬Y ∧ α), for some variable Y , while preserving equivalence and the decision property. Moreover, as long as the variable Y does not appear in α and is not an ancestor of α, then decomposability is also preserved (that is, the resulting sentence is in FBDD). Note here that " ancestor " is with respect to the binary decision diagram notation of Σ–see left of Figure 2. Now, suppose that (X ∧ α) ∨ (¬X ∧ β) is an or-node in Σ. Suppose further that the or-node is not smooth. Hence, there is some Y which appears in Vars(β) but not in Vars(α) (or the other way around). Since Σ is decomposable, then Y cannot be an ancestor of α (since in that case it would also be an ancestor of β, which is impossible by decomposability of Σ). Hence, we can replace α with (Y ∧ α) ∨ (¬Y ∧ α), while preserving equivalence, decision and decomposability. By repeating the above process, we can smooth Σ while preserving all the necessary properties. Finally, note that for every or-node (X ∧ α) ∨ (¬X ∧ β) in Σ, we need to repeat the above process at most Proof: Let Σ be a sentence in L. First, we test if Σ is inconsistent (can be done in polytime). If it is, we return the empty set of models. Otherwise, we construct a decision-tree representation of the models of Σ. Given an ordering of the variables x 1 , . . . , x n of Vars(Σ), we start with a tree T consisting of a single root node. For i = 1 to n, we repeat the following for each leaf node α (corresponds to a consistent term) in T : a. If Σ | α ∧ x i is consistent, we add x i as a child to α; b. If Σ | α ∧ ¬x i is consistent, we add ¬x i as a child to α. The key points are: • Test (a) and Test (b) can be performed in time polynomial in the size of Σ (since L satisfies CO and CD). • Either Test (a) or Test (b) above must succeed (since Σ is consistent). Hence, the number of tests performed is O(mn), where m is the number of leaf nodes in the final decision tree (bounded by the number of models of Σ) and n is the number of variables of Σ. Proof: α ∨ β is valid iff ¬α ∧ ¬β is inconsistent. Since ¬α and ¬β share no variables, then ¬α ∧ ¬β is inconsistent iff ¬α is inconsistent or ¬β is. This is true iff α is valid or β is valid. ) is equivalent to clause γ, is in d-DNNF, and can be constructed in polytime in size of γ. Now let α be the term equivalent to ¬γ. We have that Σ ∨ γ is equivalent to ((Σ | α) ∧ α) ∨ β. The last sentence is in d-DNNF and can be constructed in polytime in size of Σ and γ.

2

Lemma A.7 If a subset of NNF satisfies VA and CD, then it also satisfies IM. Proof: To test whether a consistent term α entails sentence Σ, α |= Σ, it suffices to test whether ¬α ∨ Σ is valid. This sentence is equivalent to ¬α ∨ (α ∧ Σ), to ¬α ∨ (α ∧ (Σ | α)), and to ¬α ∨ (Σ | α). Since ¬α and Σ | α share no variables, the disjunction is valid iff ¬α is valid or Σ | α is valid (by Lemma A.5). ¬α cannot be valid since α is consistent. Σ | α can be constructed in polytime since the language satisfies CD and its validity can be tested in polytime since the language satisfies VA. Proof: It is straightforward to convert a clause or term into an equivalent sentence in BDD. In order to generate a BDD sentence corresponding to the conjunction (resp. disjunction) of BDD sentences α and β, it is sufficient to replace the 1-sink (resp. 0-sink) of α with the root of β.

2

Lemma A.9 If a subset of NNF satisfies EQ, then it satisfies CO and VA. Proof: true and false belong to every NNF subset. Σ is inconsistent iff it is equivalent to false. Σ is valid iff it is equivalent to true. The validity of Σ ∨ γ can be tested in time polynomial in the size of Σ and γ. Proof: Construct Σ ∨ γ in polytime as given in Lemma A.6 and check its validity, which can be done in polytime too. Proof: Without loss of generality, assume that Σ is given by the disjunctively-interpreted set of its models (over Vars(Σ)). Conditioning Σ on γ leads (1) to removing every model of ¬γ, then (2) projecting the remaining models so that every variable of γ is removed. Conjoining Σ with γ leads exactly to (1), while forgetting every variable of γ in the resulting formula leads exactly to (2) (Lang, Liberatore, & Marquis, 2000).

2

Lemma A.13 Each sentence Σ in f-NNF can be converted into an equivalent sentence Σ * in polynomial time, where Σ * ∈ CNF or Σ * ∈ DNF. Proof: We consider three cases for the sentence Σ:

1.

The root node of Σ is an and-node. In this case, Σ can be turned into a CNF sentence Σ * in polynomial time by simply ensuring that each or-node in Σ is a clause (that is, a disjunction of literals that share no variables). Let C be an or-node in Σ. Since Σ is flat and its root is an and-node, C must be a child of the root of Σ and the children of C must be leaves. Hence, we can easily ensure that C is a clause as follows: • If we have one edge from C to some leaf X and another edge from C to ¬X (C is valid), we replace the edge from the root to C by an edge from the root to true.

•

If we have more than one edge from C to the same leaf node X, we keep only one of these edges and delete the rest.

2.

The root of Σ is an or-node. Σ can be turned into a DNF sentence Σ * in a dual way. 5 3. The root of Σ is a leaf node. Σ is already a CNF sentence.

6

Proof: This is a folklore result, immediate from the definitions.

2

Proof of Proposition 3.1 The proof of this proposition is broken down into eight steps. In each step, we prove a number of succinctness relationships between different languages, and then apply transitivity of the succinctness relation to infer even more relationships. Associated with each step of the proof is a table in which Table 9 : we mark all relationships that are proved in that step–we don't show these marks in the very first table though. Table 8: Follows immediately from the language inclusions reported in Figure 4 . Table 9: We can prove both that DNF ≤ PI and CNF ≤ IP (this slightly generalizes the results DNF ≤ CNF and CNF ≤ DNF given in (Gogic et al., 1995)). Let us consider the CNF formula Σ n = n−1 i=0 (x 2i ∨ x 2i+1 ). This formula is in prime implicates form 7 (and each clause in Σ n is an essential prime implicate of it). Hence its negation ¬Σ n is in prime implicants form (as an easy consequence of Lemma A.14). Since Quine's early work (Quine, 1959), we know that the number of essential prime implicants (resp. prime implicates) of a formula is a lower bound of the number of terms (resp. clauses) that can be found in any DNF (resp. CNF) representation of it (indeed, any such representation must include the essential prime). Σ n has 2 n essential prime implicants. Indeed, this can be easily shown by induction on n given that (i) every literal occurring in Σ n occurs only once, (ii) the set of prime implicants of any nontautological clause is the set of literals occurring in it (up to logical equivalence), and (iii) the distribution property for prime implicants (see e.g., (dual of) Proposition 40 in (Marquis, 2000)) which states that IP (α ∧β) = max({PI α ∧PI β | PI α ∈ IP (α), PI β ∈ IP (β)}, |=) (up to logical equivalence). Subsequently, ¬Σ n has 2 n essential prime implicates (cf. Lemma A.14). Accordingly, we obtain that both DNF ≤ PI and CNF ≤ IP. We also obtain PI ≤ IP and IP ≤ PI. Now, it is well–known that some DNF formulas have exponentially many prime implicants (see the proof of Proposition 5.1 where we show that IP does not satisfy SFO). Hence, their negations are CNF 5. Note that f-NNF satisfies ¬C and that the negation of a CNF sentence (resp. DNF sentence) can be turned into a DNF (resp. CNF) in linear time. 6. A prime implicant (resp. a prime implicate) α of Σ is essential iff the disjunction (resp. conjunction) of all prime implicants (resp. prime implicates) of Σ except α is not equivalent to Σ. 7. The correctness of (the dual of) Quine's consensus algorithm for computing prime implicants (Quine, 1955) ensures it, since no clause of Σ n is subsumed by another clause and no consensi can be performed since there are no negated variables. Table 11: formulas having exponentially many prime implicates. Subsequently IP ≤ DNF and PI ≤ CNF. The remaining results in this table follow from the transitivity of ≤. Table 10: The parity function O n = n−1 i=0 x i has linear size OBDD < representations (Bryant, 1986 ) but only exponential size CNF and DNF representations. The reason is that O n has 2 n essential prime implicants (resp. essential prime implicates) and the number of essential prime implicants (resp. essential prime implicates) of a formula is a lower bound of the size of any of its DNF (resp. CNF) representation. This easily shows that both CNF ≤ OBDD and DNF ≤ OBDD. The remaining results in this table follow from the language inclusions reported in Figure 4. Table 11: It is shown in (Darwiche, 2001b ) that there is a sentence in d-DNNF which only has exponential FBDD representations. Accordingly, we have FBDD ≤ d-DNNF. In (Gergov & Meinel, 1994a), it is shown that OBDD ≤ FBDD. Finally, it is easy to show that OBDD < ≤ OBDD (for instance, the formula Σ n = n i=1 (x i ⇔ y i ) has an OBDD < representation of size polynomial in n whenever < satisfies x 1 < y 1 < x 2 < . . . < x n < y n , while it has an OBDD < representation of size exponential in n provided that < is s.t. x 1 < x 2 < . . . < x n < y 1 < y 2 < . . . < y n ). The remaining results in this table follow from the language inclusions reported in Figure 4 . Table 12: L' ≤ * L means that L' ≤ L unless the polynomial hierarchy PH collapses. The results in this table follow since the existence of polysize knowledge compilation functions for clausal entailment implies the collapse of the polynomial hierarchy PH (Selman & Kautz, 1996; Cadoli & Donini, 1997). Now, if DNNF ≤ CNF, then for each sentence Σ in CNF there exists a polysize equivalent sentence Γ in DNNF. Therefore, we can test whether a clause is entailed by Σ in polytime by testing whether the clause is entailed by Γ. This proves the existence of polysize knowledge compilation functions for clausal entailment, leading to the collapse of the polynomial hierarchy PH. The same is true for d-DNNF and sd-DNNF since all these languages support a polytime clausal entailment test (see Proposition 4.1). Table 13: In (Wegener, 1987 ) (Theorem 6.2 pp. 436), a family of n 2 -variable boolean functions Σ is pointed out. Provided that every interpretation I over these n 2 variables represents a n-vertices digraph (for every 1 ≤ i, j ≤ n, we have I(x i,j ) = 1 iff (i, j) is an arc of the digraph), Σ(I) = 1 iff the Table 13: digraph represented

by

I contains a k-clique of a special kind (k is a parameter of the family). It is shown that for certain values of k (depending on n), every FBDD representation of Σ has exponential size. Moreover, it is shown that Σ has only a cubic number of prime implicants. This shows that FBDD ≤ IP, hence FBDD ≤ DNF. Because FBDD satisfies ¬C (see Proposition 5.1), 8 it cannot be the case that ¬Σ has a polynomial size FBDD. Since ¬Σ has only a cubic number of prime implicates, we obtain that FBDD ≤ PI, hence FBDD ≤ CNF. The remaining results in this table follow since FBDD≤ OBDD ≤ OBDD < . Table 14: Assume that d-DNNF ≤ DNF holds. As a consequence, every sentence Σ in DNF can be compiled into an equivalent d-DNNF sentence Σ * of polynomial size. Now, checking whether a clause γ is entailed by the CNF sentence Σ is equivalent to checking whether the DNF sentence ¬Σ ∨ γ is valid. Checking whether (¬Σ) * ∨γ is valid—when (¬Σ) * is a d-DNNF sentence and γ is a clause—can be achieved in polynomial time by Lemma A.11. Therefore, (¬Σ) * is a polysize compilation of the 8. That is, a sentence in FBDD can be negated in polytime to yield a sentence in FBDD too. CNF sentence Σ, allowing clausal entailment to be achieved in polynomial time. The existence of such (¬Σ) * for every CNF sentence Σ implies the collapse of the polynomial hierarchy (Selman & Kautz, 1996; Cadoli & Donini, 1997). Hence, we obtain that d-DNNF ≤ * DNF. As a consequence, we also have d-DNNF ≤ * DNNF. Finally, since every d-DNNF sentence can be turned in polynomial time into an equivalent sd-DNNF sentence by Lemma A.1, we have sd-DNNF ≤ d-DNNF. Moreover, since d-DNNF ≤ sd-DNNF, we obtain sd-DNNF ≤ * DNF, sd-DNNF ≤ * DNNF, sd-DNNF ≤ FBDD, sd-DNNF ≤ OBDD, sd-DNNF ≤ OBDD < , FBDD ≤ sd-DNNF, OBDD < ≤ sd-DNNF, DNF ≤ sd-DNNF, CNF ≤ sd-DNNF, PI ≤ sd-DNNF and IP ≤ sd-DNNF. Table 15: Let us now show that MODS is not less succinct than PI, IP, sd-DNNF and OBDD. First, let us consider the formula Σ = n i=1 x i . Σ can be represented by PI, IP, sd-DNNF and OBDD formulas of size polynomial in n. Contrastingly, Σ cannot be represented by a MODS formula of size polynomial in n since Σ has 2 n − 1 models over Vars(Σ). Now, it is well-known that the old good Quine-McCluskey's algorithm for generating prime implicants from a MODS representation of a propositional formula Σ runs in time polynomial in the number of models of Σ (Wegener, 1987). This shows that IP ≤ MODS. As to CNF and OBDD < , it is obvious that a decision tree (or Shannon tree) for Σ that respects a given total ordering over Vars(Σ) can be generated in polynomial time from a MODS representation of Σ. Such a decision tree has m 1-leaves where m is the number of models of Σ over Vars(Σ). Accordingly, it has at most n * m 0-leaves where n = |Vars(Σ)|. Since the set of all paths from the root of the tree to any 0-leaf can be read as a CNF representation of Σ, we obtain that CNF ≤ MODS. On the other hand, since reducing a decision tree to derive a corresponding OBDD < can be done in polynomial time, it follows that an OBDD < representation of Σ can also be generated from a MODS representation of it. Hence, OBDD < ≤ MODS. The remaining results in this table follow from the language inclusions reported in Figure 4. 2 Proof of Proposition 4.

1

The proof of this proposition is broken down into twelve steps. In each step, we prove a number of results. Associated with each step of the proof is a table in which we mark all results that are proved in that step. The table of the last step includes all results declared by this proposition. Table 16: Every classical CNF or DNF formula can be translated in a straightforward way into an equivalent f-NNF sentence (with a tree structure) in polytime. Moreover, every NNF sentence can be translated into an equivalent s-NNF sentence in polytime (Lemma A.1). Given that CO is NP-hard (resp. VA is coNP-hard) for classical CNF (resp. DNF) sentences, and the inclusion between the various NNF subsets reported in Figure 4, we obtain the table. Table 17: SE implies both CO and VA (Lemma A.10). Moreover, since CT implies both CO and VA, IM implies VA (valid term), and CE implies CO (inconsistent clause), we obtain the table. Table 20: Table 18: A sentence Σ is consistent (resp. valid) iff it has a model (resp. 2 n models, where n = |Vars(Σ)|). Moreover, the number of models of Σ is given by the number of edges outgoing from the or-node in any MODS representation of Σ. Accordingly, CO, VA and CT can be achieved in polynomial time when Σ is given by a MODS formula which gives us the table. Table 19: Because DNNF satisfies CE (Darwiche, 2001a ), CE implies CO and MODS ⊆ DNF ⊆ DNNF, IP⊆ DNF and sd-DNNF ⊆ d-DNNF ⊆ DNNF, we obtain the table. Table 20: We now use the following results: CD and CO imply CE (Lemma A.4). CD and VA imply IM (Lemma A.7).

CD and

CO imply ME (Lemma A.3). All considered NNF subsets satify CD (cf. Proposition 5.1). If an NNF subset does not satisfy CO it cannot satisfy ME. It is well-known that FBDD satisfies CO, VA and CT, and that OBDD < satisfies (in addition) EQ (Gergov & Meinel, 1994a; Bryant, 1992). Since Σ |= α holds iff Σ ∧ ¬α is inconsistent and since OBDD < satisfies CO, ¬C and ∧BC (cf. Proposition 5.1), OBDD < also satisfies SE. Obviously enough, any query concerning OBDD is equivalent to the corresponding query concerning OBDD < provided that only one DAG is brought into play. Together with the above results, we conclude that OBDD satisfies CO, VA and CT. Since this fragment satisfies CD as well, it satisfies CE, IM and ME in addition. It also satisfies EQ (see Theorem 8.11 from (Meinel & Theobald, 1998)) but does not satisfy SE (unless P = NP). Indeed, it is known that checking the consistency of two OBDD < formulas α and β (based on two different variable orderings <) is NP-complete (Lemma 8.14 from (Meinel & Theobald, 1998)). Since OBDD satisfies ¬C and since α ∧ β is consistent iff α |= ¬β, checking sentential entailment for OBDD formulas is coNP-complete. These results lead to the table. Table 21: It is known that IM is satisfied by classical CNF formulas (hence, PI) (in order to check whether a non-valid clause is implied by a consistent term, it is sufficient to test that they share a literal). CNF (hence, PI) is also known to satisfy VA. We then obtain the table. Table 22: Every sentence in CNF or DNF can be turned into an equivalent sentence in BDD in polytime (Lemma A.8). Hence, a • in a CNF or DNF cell implies a • in the corresponding BDD cell. Similarly, since BDD ⊆ d-NNF, a • in a BDD cell implies a • in the corresponding d-NNF cell. This leads to the table. Table 23: Since EQ implies CO and VA (Lemma A.9), a • in a CO or VA cell implies a • in the corresponding EQ cell. This leads to the table. Table 24: By definition, PI satisfies CE and IP satisfies IM. Since PI ⊆ CNF and IP ⊆ DNF, this implies that both PI and IP satisfy SE. Now, SE implies EQ, hence both PI and IP satisfy EQ (actually, two equivalent formulas share the same prime implicates and the same prime implicants (both forms are canonical ones, provided that one representative per equivalence class is considered, only)). Since PI satisfies CE, it also satisfies CO. Since it satisfies CD as well (cf. Proposition 5.1), it also satisfies ME (Lemma A.3). Contrastingly, the models counting problem for monotone Krom formulas (i.e. conjunctions of clauses containing at most two literals and only positive literals) is #P-complete (Roth, 1996). Such formulas can easily be turned into prime implicates form in polynomial time (Marquis, 2000), hence PI does not satisfy CT. Now, since the negation of a formula Σ in prime implicates form is a formula in prime implicants form (cf. Lemma A.14), and since the number of models of ¬Σ over Vars(Σ) is 2 |Vars(Σ)| minus the number of models of Σ over Vars(Σ), we necessarily have that IP does not satisfy CT. This also imply that IP satisfies VA, leading to the table. Table 25: In the proof of Proposition 3.1, we have shown that the prime implicants of Σ can be computed in polytime from a MODS representation of Σ. As an immediate consequence, since IP satisfies IM, EQ and SE, we obtain that MODS satisfies IM, EQ and SE, leading to the table. Table 26: Since d-DNNF satisfies CT (Darwiche, 2001b), it also satisfies VA. Since it satisfies CD (Proposition 5.1), it also satisfies IM as well (Lemma A.7). Since sd-DNNF ⊆ d-DNNF, these results follow for sd-DNNF. Hence, we obtain the table. Table 27: It is known that determining whether the conjunction of two FBDD formulas α 1 and α 2 is consistent is NP-complete (Gergov & Meinel, 1994b) Moreover, FBDD satisfies ¬C. Since α 1 ∧ α 2 is inconsistent iff α 1 |= ¬α 2 , we can reduce the consistency test into an entailment test. Hence, FBDD does not satisfy SE. Since FBDD ⊆ d-DNNF, d-DNNF does not satisfy SE either. Finally, since every d-DNNF can be translated into an equivalent sd-DNNF sentence in polytime (Lemma A.1), sd-DNNF does not satisfy SE either. This leads to the final table above. Table 27: Proof of Proposition 5.

1

The proof of this proposition is broken down into eight steps. Each step corresponds to one of the transformations, where we prove all results pertaining to that transformation. • CD. To show that a language L satisfies CD, we want to show that for any sentence Σ ∈ L and any consistent term γ, we can construct in polytime a sentence which belongs to L and is equivalent to Σ | γ. – NNF, f-NNF, CNF and DNF. The property is trivially satisfied by these languages: If Σ belongs to any of these languages, then replacing the literals of γ by a Boolean constant in Σ results a sentence in the same language. In the case of DNF (resp. CNF), some inconsistent terms (valid clauses) may result through conditioning, but these can be removed easily in polynomial time. – DNNF. It is sufficient to prove that conditioning preserves decomposability. For every propositional sentences α, β and every consistent term γ, if α and β do not share variables, then α|γ and β|γ do not share variables either since – d-NNF and d-DNNF. Since NNF and DNNF satisfy CD, it is sufficient to prove that conditioning preserves determinism, i.e. for every propositional formulas α, β and every consistent term γ, Since γ is consistent and share no variable with (α ∧ β)|γ, it must be the case that (α ∧ β)|γ is inconsistent. This is equivalent to state that (α|γ) ∧ (β|γ) |= false. – s-NNF and sd-DNNF. Since NNF satisfies CD, and since conditioning preserves decomposability and determinism, all we have to show is that conditioning also preserves smoothness . This follows immediately since for two propositional sentences α, β and a consistent term γ, we have – BDD, FBDD, OBDD and OBDD < . It is well–known that BDD satisfies CD—the conditioning operation on binary decision diagrams is known as the restrict operation (Bryant, 1986). To condition a sentence Σ in BDD on a consistent term γ, we replace every node labeled by a variable in γ by one of its two children, according to the sign of the variable in γ. The resulting sentence is also a BDD and is equivalent to Σ | γ. The same applies to FBDD, OBDD and OBDD < . – PI. The prime implicates of Σ ∧ γ can be computed in polytime when Σ is in prime implicates form and γ is a term (see Proposition 36 in (Marquis, 2000)). Moreover, since PI satisfies FO (see below), the prime implicates of ∃Vars(γ).(Σ ∧ γ) can be computed in polytime. But these are exactly the prime implicates of Σ | γ according to Lemma A.12. – IP. Let Σ = n i=1 γ i be a formula in prime implicants form. It is clear that the formula ( n i=1 γ i ) | γ is a DNF formula equivalent to Σ | γ. Now, our claim is that the formula Σ * obtained by keeping only the logically weakest terms γ i | γ among ( n i=1 γ i ) | γ is a prime implicants formula equivalent to Σ | γ. Removing such terms clearly is truth-preserving. Since generating Σ * requires only O(n 2 ) entailment tests among terms, and since such tests can be easily achieved in polynomial time, we obtain that IP satisfies CD. Now, how to prove that Σ * is in prime implicants form? Since any pair of different terms of Σ * cannot be compared w.r.t. logical entailment, the correctness of Quine's consensus algorithm for generating prime implicants shows that it is sufficient to prove that every consensus among two terms of Σ * is inconsistent or entails another term of Σ * . Let's recall that consensus is to DNF formulas what resolution is to CNF formulas. Since Σ is in prime implicants form, every consensus among two terms of Σ is inconsistent or entails another term of Σ. What happens to the terms (here, the prime implicants) of Σ when conditioned by γ? All those containing the negation of a literal of γ are removed and the remaining ones are shortened by removing from them every literal of γ. Hence, for every pair of terms γ 1 , γ 2 of Σ, if there is no consensus between γ 1 and γ 2 , then there is no consensus between γ 1 |γ and γ 2 |γ: conditioning cannot create new consensus. Now, it remains to prove that no unproductive consensus between terms of Σ can be rendered productive through conditioning. Formally, let γ 1 = γ 1 ∧ l and γ 2 = γ 2 ∧ ¬l be two prime implicates of Σ s.t. l (resp. ¬l) does not appear in γ 1 (resp. γ 2 ). There is a consensus γ 1 ∧γ 2 between γ 1 and γ 2 . Let us assume that both γ 1 and γ 2 have survived the conditioning: this means that both γ 1 |γ and γ 2 |γ are consistent. Especially, l belongs to γ 1 |γ and ¬l belongs to γ 2 |γ. Accordingly, there is a consensus between γ 1 |γ and γ 2 |γ. By construction, this consensus is equivalent to (γ 1 |γ)∧(γ 2 |γ), hence equivalent to (γ 1 ∧γ 2 )|γ. Now, if γ 1 ∧ γ 2 is inconsistent, then (γ 1 ∧ γ 2 )|γ is inconsistent as well and we are done. Otherwise, let us assume that there exists a prime implicant γ 3 of Σ s.t. γ 1 ∧ γ 2 |= γ 3 holds. Necessarily, γ 3 is preserved by the conditioning of Σ by γ. Otherwise, γ 3 would contain the negation of a literal of γ, but since every literal of γ 3 is a literal of γ 1 or a literal of γ 2 , γ 2 and γ 3 would not have both survived the conditioning. Since γ 1 ∧ γ 2 |= γ 3 holds, we necessarily have (γ 1 ∧ γ 2 )|γ |= γ 3 |γ. This completes the proof. – MODS. Direct consequence of Lemma A.12 and the fact that MODS satisfies ∧BC and FO (see below).

•

FO. – DNNF and DNF. It is known that DNNF satisfies FO (Darwiche, 2001a). It is also known that DNF satisfies FO (Lang et al., 2000). – NNF, s-NNF, f-NNF, d-NNF, BDD and CNF. Let Σ be a sentence in CNF. We now show that if any of the previous languages satisfies FO, then we can test the consistency of Σ in polytime. Since CNF does not satisfy CO (see Proposition 4.1), it then follows that none of the previous languages satisfy FO unless P = NP. First, we note that Σ must also belong to NNF and f-NNF. Moreover, Σ can be turned into a sentence in BDD in polytime (Lemma A.8) or a sentence in s-NNF in polytime (see the proof of Lemma A.1). We also have that Σ can be turned into a sentence in d-NNF in polytime since BDD ⊆ d-NNF. Suppose now that one of the previous languages, call it L, satisfy FO. We can test the consistency of Σ in polytime as follows: * Convert Σ into a sentence Σ * in L in polytime (as shown above). which can be done in polytime since the sentence contains no variables—all we have to do is check whether the sentence evaluates to true. Finally, note that the definition of forgetting implies that a sentence Γ is consistent iff ∃Vars(Γ).Γ is valid, which completes the proof. – d-DNNF and sd-DNNF. Follows immediately since none of these languages satisfies SFO unless P = NP (see below). – IP. Follows immediately since IP does not satisfy SFO. – FBDD, OBDD and OBDD < . We will show that if FBDD (resp. OBDD, OBDD < ) satisfies FO, then for every sentence Γ in DNF, there must exist an equivalent sentence Σ in FBDD (resp. OBDD, OBDD < ), which size is polynomial in the size of Γ. This contradicts the fact that FBDD (resp. OBDD, OBDD < ) ≤ DNF—see Table 3. Given a DNF Γ consisting of terms γ 1 , ..., γ n , we can convert each of these terms into equivalent FBDD (resp. In case of OBDD and OBDD < , we also assume that these new variables are earlier than variables P S in the ordering. Clearly enough, an FBDD (resp. OBDD, OBDD < ) sentence equivalent to ∆ 1 can be computed in time polynomial in the input size. Moreover, we have Σ ≡ n i=1 α i ≡ n i=1 γ i ≡ Γ. Hence, if FBDD (resp. OBDD, OBDD < ) satisfies FO, then we can convert the DNF sentence Γ into an equivalent FBDD (resp. OBDD, OBDD < ) which size is polynomial in the size of the given DNF. This is impossible in general. – PI. It is known that the prime implicates of ∃X.Σ are exactly the prime implicates of Σ that do not contain any variable from X (see Proposition 55 in (Marquis, 2000)). Hence, such prime implicates can be computed in time polynomial in the input size when Σ is in prime implicates form. – MODS. Given a MODS formula Σ and a subset X of P S, the formula obtained by removing every leaf node (and the corresponding incoming edges) of Σ labeled by a literal x or ¬x s.t. x ∈ X is a MODS representation of ∃X.Σ—this is an easy consequence of Propositions 18 and 20 from (Lang et al., 2000). See also the polytime operation of forgetting on DNNF, as defined in (Darwiche, 2001a), which applies to MODS, since MODS ⊆ DNNF, and which can be easily modified so it guarantees that the output is in MODS when the input is also in MODS. • SFO. – DNNF, DNF, PI and MODS. Immediate from the fact that each of these languages satisfies FO (see above). – NNF, d-NNF, s-NNF, f-NNF, BDD, OBDD < and CNF. Direct from the fact that ∃x.Σ ≡ (Σ|x) ∨ (Σ|¬x) holds and the fact that any of these fragments satisfies CD and ∨BC. – OBDD. Direct from the fact that only one OBDD sentence is considered in the transformation and OBDD < satisfies SFO. – d-DNNF, sd-DNNF and FBDD. Let α 1 and α 2 be two FBDD formulas. formula since decomposability and decision are preserved by this construction. Since ∃x.Σ is equivalent to α 1 ∨ α 2 , if FBDD would satisfy SFO, it would satisfy ∨BC as well, but this is not the case unless P = NP (see below). The same conclusion can be drawn for d-DNNF. Hence, FBDD and d-DNNF do not satisfy SFO unless P = NP. Since every d-DNNF formula can be turned in polynomial time into an equivalent sd-DNNF formula, we obtain that sd-DNNF does not satisfy SFO unless P = NP. – IP. Let us show that the number of prime implicants of ∃x.Σ can be exponentially greater than the number of prime implicants of Σ. Let Σ be the following DNF formula: Since Σ can be obtained from Σ by removing in every term of Σ every occurrence of x and ¬x, Σ is equivalent to ∃{x}.Σ (see (Lang et al., 2000)). Now, Σ has only mk + 1 prime implicants; indeed, every term of it is a prime implicant, and the converse holds since every term is maximal w.r.t. logical entailment and every consensus of two terms is inconsistent. This completes the proof.

• ∧C.

– NNF, s-NNF, d-NNF, CNF. The property is trivially satisfied by these languages since determinism and smoothness are only concerned with or-nodes. Hence, if α 1 , . . . , α n belong to one of these languages, so is α 1 ∧ . . . ∧ α n . – BDD. It is well–known that the conjunction of two BDDs α and β can be easily computed by connecting the 1-sink of α to the root of β (see proof of Lemma A.8). The size of the resulting BDD is just the sum of the sizes of the respective BDDs of α and β. Accordingly, we can repeat this operation n times in time polynomial in the input size. – f-NNF. Direct from the fact that f-NNF does not satisfy ∧BC. – FBDD, OBDD, OBDD < , DNF, PI and IP. It is straightforward to convert a clause into an equivalent formula in any of these languages in polynomial time. In the proof of Proposition 3.1, we show specific CNF formulas which cannot be turned into an equivalent FBDD (resp. OBDD, OBDD < , DNF, PI and IP) formulas in polynomial space (see Tables 9 and 10). Hence, such conversion cannot be accomplished in polynomial time either. This implies that none of FBDD, OBDD, OBDD < , DNF, PI and IP satisfies ∧C. – DNNF, d-DNNF and sd-DNNF. Direct from the fact that none of these languages satisfy ∧BC unless P = NP. n models, it does not have a MODS representation of size polynomial in the input size. • ∧BC. – NNF, s-NNF, d-NNF, BDD and CNF. Immediate since each of these languages satisfy ∧C (see above). – DNNF, d-DNNF, sd-DNNF, FBDD and OBDD. Checking whether the conjunction of two OBDD < formulas α 1 and α 2 (w.r.t. two different variable orderings <) is consistent is NP-complete (see Lemma 8.14 in (Meinel & Theobald, 1998)). Since OBDD satisfies CO, it cannot satisfy ∧BC unless P = NP. Since OBDD ⊆ FBDD ⊆ d-DNNF ⊆ DNNF, and d-DNNF and DNNF satisfy CO, none of them can satisfy ∧BC unless P = NP. Finally, since every d-DNNF formula can be turned in polynomial time into an equivalent smoothed d-DNNF formula and since sd-DNNF satisfies CO, it cannot be the case that sd-DNNF satisfy ∧BC unless P = NP. – OBDD < . Well-known fact (Bryant, 1986). – f-NNF. Let α 1 = n−1 i=0 (x 2i ∨ x 2i+1 ) be a CNF formula and α 2 = n−1 i=0 (x 2i ∧ x 2i+1 ) a DNF formula. α 1 has 2 n essential prime implicants and n essential prime implicates (see the proof of Proposition 3.1, Table 9). By duality, α 2 has n essential prime implicants and 2 n essential prime implicates. Now, α 1 and α 2 are two f-NNF formulas. By Lemma A.13, we know that every f-NNF formula β can be turned in polynomial time into a CNF formula or a DNF formula. If f-NNF would satisfy ∧BC, then a f-NNF formula β s.t. β ≡ α 1 ∧α 2 could be computed in time polynomial in the input size. Hence, either a CNF formula equivalent to α 1 ∧ α 2 or a DNF formula equivalent to α 1 ∧ α 2 could be computed in polytime. But this is impossible since α 1 ∧ α 2 has n + 2 n essential prime implicates and n * 2 n essential prime implicants. Hence every CNF (resp. DNF ) formula equivalent to α 1 ∧ α 2 has a size exponential in |α 1 | + |α 2 |. Note that in the case where the two f-NNF formulas α 1 and α 2 into consideration can be turned in polynomial time into either two CNF formulas or two DNF formulas, then a f-NNF formula equivalent to α 1 ∧ α 2 can be computed in time polynomial in the input size (this is obvious when two CNF formulas are considered and the next item of the proof shows how this can be achieved when two DNF formulas are considered). – DNF and MODS. If α 1 and α 2 are sentences in one of these languages L, then we can construct a sentence in L which is equivalent to α 1 ∧ α 2 by simply taking all the conjunctions of one term from α 1 and one term from α 2 , while removing redundant literals in the resulting terms and removing any inconsistent terms in the result. The disjunction of all the resulting terms is a sentence from L equivalent to α 1 ∧ α 2 and it has been computed in polynomial time. – NNF, s-NNF, DNNF and DNF. The property is trivially satisfied by these languages since decomposability is only concerned with and-nodes, and since every NNF formula can be turned in polynomial time into an equivalent smoothed NNF formula. – d-NNF and BDD. Direct consequence from the fact that d-NNF and BDD satisfies both ∧C and ¬C. Especially, it is well-known that the disjunction of two BDDs α and β can be easily computed by connecting the 0-sink of α to the root of β (see the proof of Lemma A.8). The size of the resulting BDD is just the sum of the sizes of the respective BDDs of α and β. Accordingly, we can repeat this operation n times in time polynomial in the input size. – f-NNF. Since f-NNF does not satisfy ∧C but satisfies ¬C, it cannot satisfy ∨C (due to De Morgan's laws). – FBDD, OBDD, OBDD < , CNF, PI, IP and MODS. It is straightforward to convert any term into an equivalent formula from any of the previous languages in polynomial time. In the proof of Proposition 3.1, we show specific DNF formulas which cannot be turned into equivalent FBDD (resp. OBDD, OBDD < , CNF , PI, IP and MODS) formulas in polynomial space (see Tables 9, 10 and 15). Hence, the conversion cannot be accomplished in polynomial time either. This implies that none of FBDD, OBDD, OBDD < , CNF, PI, IP and MODS satisfies ∨C. – d-DNNF and sd-DNNF. Immediate form the fact that none of these classes satisfies ∨BC unless P = NP (see below).

• ∨BC.

– NNF, d-NNF, DNNF, s-NNF, BDD and DNF. Immediate since each of these languages satisfies ∨C. – OBDD < . Well-known fact (Bryant, 1986). – OBDD, FBDD, d-DNNF and sd-DNNF. Checking whether the conjunction of two OBDD < formulas α 1 and α 2 (w.r.t. two different variable orderings <) is consistent is NP-complete (see Lemma 8.14 in (Meinel & Theobald, 1998)). Now, α 1 ∧ α 2 is inconsistent iff ¬α 1 ∨ ¬α 2 is valid. Since OBDD satisfies ¬C, an OBDD formula equivalent to ¬α 1 (resp. ¬α 2 ) can be computed in time polynomial in |α 1 | (resp. |α 2 |). Since OBDD ⊆ FBDD ⊆ d-DNNF, the resulting formulas are also FBDD and d-DNNF formulas. If OBDD (resp. FBDD, d-DNNF) would satisfy ∨BC, then an OBDD (resp. FBDD, d-DNNF) formula equivalent to ¬α 1 ∨ ¬α 2 could be computed in time polynomial in |α 1 | + |α 2 |. But since d-DNNF satisfies VA, this is impossible unless P = NP. Finally, since every d-DNNF formula can be turned in polynomial time into an equivalent sd-DNNF formula, sd-DNNF cannot satisfy ∨BC unless P = NP. – f-NNF. Since f-NNF does not satisfy ∧BC but satisfies ¬C, it cannot satisfy ∨BC (due to De Morgan's laws). – CNF. If α 1 and α 2 are two CNF sentences, then we can construct a CNF sentence which is equivalent to α 1 ∨ α 2 by simply taking all the disjunctions of one clause from α 1 and one clause from α 2 , while removing redundant literals inside the resulting clauses and removing any valid clause in the result. The conjunction of all the resulting clauses is a CNF sentence equivalent to α 1 ∨ α 2 , and it has been computed in polynomial time. – PI. Let PI (α) be the set of prime implicates for sentence α. – NNF, s-NNF, f-NNF, BDD, FBDD, OBDD and OBDD < . The property is obviously satisfied by NNF. s-NNF also satisfies ¬C since every NNF formula can be turned in polynomial time into an equivalent s-NNF formula. f-NNF satisfies ¬C since applying De Morgan's laws on a f-NNF formula results in a f-NNF formula. Finally, for all the forms of BDDs, it is sufficient to switch the labels of the sinks to achieve negation (Bryant, 1986). – CNF. Because the negation of a DNF formula is a CNF formula that can be computed in polynomial time, if CNF would satisfy ¬C, then it would be possible to turn any DNF formula into an equivalent CNF formula in polynomial time (by involution of negation). But we know that it is not possible in polynomial space since CNF ≤ DNF(see the proof of Proposition 3.1). Hence, CNF does not satisfy ¬C. – DNF. Dual of the proof just above (just replace CNF by DNF and vice-versa). – PI. The formula Σ n = n−1 i=0 (x 2i ∨ x 2i+1 ) is in prime implicates form (see the proof of Proposition 3.1, Table 9). This formula has exponentially many prime implicants, that are just the negations of the prime implicates of ¬Σ n . Since ¬Σ n has exponentially many prime implicates, it cannot be the case that PI satisfies ¬C. – IP. We just have to take the dual of the above proof (prime implicates case). The formula Σ n = n−1 i=0 (x 2i ∧x 2i+1 ) is in prime implicants form. This formula has exponentially many prime implicates, that are just the negations of the prime implicants of ¬Σ n . Since ¬Σ n has exponentially many prime implicants, it cannot be the case that IP satisfies ¬C. – DNNF. The negation of any CNF formula can be computed in polynomial time as a DNF formula, hence as a DNNF formula. If DNNF would satisfy ¬C, then it would be possible to turn a CNF formula into an equivalent DNNF one (by involution of negation). Because DNNF satisfies CO, we would have P = NP. – d-NNF. Following is a procedure for negating a d-NNF sentence ∆: 9 * Traverse nodes in the DAG of ∆, visiting the children of a node before you visit the node itself. When visiting a node, construct its negation as follows: · true is the negation of false. · false is the negation of true. i is the node representing the negation of N i , and M i is a node representing the conjunction N 1 ∧ . . . ∧ N i−1 . * Return the negation of the root of d-NNF ∆. We can implement the above four steps so that we when we visit a node with k children, we only construct O(k) nodes and O(k) edges. 10 Hence, the procedure complexity is linear in the size of the original d-NNF. It is easy to check that the result is equivalent to the negation of the given d-NNF sentence and is also in d-NNF. – sd-DNNF and d-DNNF. Unknown. – MODS. Σ = n i=1 x i has only one model over n i=1 {x i } but its negation ¬Σ has 2 n − 1 models over n i=1 {x i }. Hence MODS cannot satisfy ¬C. 2