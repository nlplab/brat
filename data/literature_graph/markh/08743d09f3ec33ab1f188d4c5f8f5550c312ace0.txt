Title: Online Passive-Aggressive Algorithms

Abstract: We present a unified view for online classification, regression, and uni-class problems. This view leads to a single algorithmic framework for the three problems. We prove worst case loss bounds for various algorithms for both the realizable case and the non-realizable case. A conversion of our main online algorithm to the setting of batch learning is also discussed. The end result is new algorithms and accompanying loss bounds for the hinge-loss.

Content: Introduction

In this paper we describe and analyze several learning tasks through the same algorithmic prism. Specifically, we discuss online classification, online regression, and online uniclass prediction. In all three settings we receive instances in a sequential manner. For concreteness we assume that these instances are vectors in R n and denote the instance received on round t by x t . In the classification problem our goal is to find a mapping from the instance space into the set of labels, {−1, +1}. In the regression problem the mapping is into R. Our goal in the uniclass problem is to find a center-point in R n with a small Euclidean distance to all of the instances. We first describe the classification and regression problems. For classification and regression we restrict ourselves to mappings based on a weight vector w ∈ R n , namely the mapping f : R n → R takes the form f (x) = w · x. After receiving x t we extend a predictionˆy t using f . For regression the prediction is simplyˆy t = f (x t ) while for classi- ficationˆy t = sign(f (x t )). After extending the predictionˆy t , we receive the true outcome y t . We then suffer an instantaneous loss based on the discrepancy between y t and f (x t ). The goal of the online learning algorithm is to minimize the cumulative loss. The losses we discuss in this paper depend on a pre-defined insensitivity parameter ǫ and are denoted ℓ ǫ (w; (x, y)). For regression the ǫ-insensitive loss is, ℓ ǫ (w; (x, y)) = 0 |y − w · x| ≤ ǫ |y − w · x| − ǫ otherwise , (1) while for classification the ǫ-insensitive loss is defined to be, ℓ ǫ (w; (x, y)) = 0 y(w · x) ≥ ǫ ǫ − y(w · x) otherwise . (2) As in other online algorithms the weight vector w is updated after receiving the feedback y t . Therefore, we denote by w t the vector used for prediction on round t. We leave the details on the form this update takes to later sections.

Problem

Example (z t ) Discrepancy (δ) Update Direction (v t ) Classification (x t , y t ) ∈ R n × {-1,+1} −y t (w t · x t ) y t x t Regression (x t , y t ) ∈ R n × R |y t − w t · x t | sign(y t − w t · x t ) x t Uniclass (x t , y t ) ∈ R n × {1} x t − w t xt−wt xt−wt Table 1: Summary of the settings and parameters employed by the additive PA algorithm for classification, regression, and uniclass. The setting for uniclass is slightly different as we only observe a sequence of instances. The goal of the uniclass algorithm is to find a center-point w such that all instances x t fall within a radius of ǫ from w. Since we employ the framework of online learning the vector w is constructed incrementally. The vector w t therefore plays the role of the instantaneous center and is adapted after observing each instance x t . If an example x t falls within a Euclidean distance ǫ from w t then we suffer no loss. Otherwise, the loss is the distance between x t and a ball of radius ǫ centered at w t . Formally, the uniclass loss is, ℓ ǫ (w t ; x t ) = 0 x t − w t ≤ ǫ x t − w t − ǫ otherwise . (3) In the next sections we give additive and multiplicative online algorithms for the above learning problems and prove respective online loss bounds. A common thread of our approach is a unified view of all three tasks which leads to a single algorithmic framework with a common analysis.

Related work:

Our work builds on numerous techniques from online learning. The updates we derive are based on an optimization problem directly related to the one employed by Support Vector Machines [15]. Li and Long [14] were among the first to suggest the idea of converting a batch optimization problem into an online task. Our work borrows ideas from the work of Warmuth and colleagues [11]. In particular, Gentile and Warmuth [6] generalized and adapted techniques from [11] to the hinge loss which is closely related to the losses defined in Eqs. (1)-(3). Kivinen et al. [10] discussed a general framework for gradient-based online learning where some of their bounds bare similarities to the bounds presented in this paper. Our work also generalizes and greatly improves online loss bounds for classification given in [3]. Herbster [8] suggested an algorithm for classification and regression that is equivalent to one of the algorithms given in this paper, however, the lossbound derived by Herbster is somewhat weaker. Finally, we would like to note that similar algorithms have been devised in the convex optimization community (cf. [1] [2]). The main difference between these algorithms and the online algorithms presented in this paper lies in the analysis: while we derive worst case, finite horizon loss bounds, the optimization community is mostly concerned with asymptotic convergence properties.

A Unified Loss

The three problems described in the previous section share common algebraic properties which we explore in this section. The end result is a common algorithmic framework that is applicable to all three problems and an accompanying analysis (Sec. 3). Let z t = (x t , y t ) denote the instance-target pair received on round t where in the case of uniclass we set y t = 1 as a placeholder. For a given example z t , let δ(w; z t ) denote the discrepancy of w on z t : for classification we set the discrepancy to be −y t (w t · x t ) (the negative of the margin), for regression it is |y t − w t · x t |, and for uniclass x t − w t . Fixing z t , we also view δ(w; z t ) as a convex function of w. Let [a] + be the function that equals a whenever a > 0 and otherwise equals zero. Using the discrepancies defined above, the three different losses given in Eqs. (1)-(3) can all be written as ℓ ǫ (w; z) = [δ(w; z) − ǫ] + , where for classification we set ǫ ← −ǫ since the discrepancy is defined as the negative of the margin. While this construction might seem a bit odd for classification, it is very useful in unifying the three problems. To conclude, the loss in all three problems can be derived by applying the same hinge loss to different (problem dependent) discrepancies.

An Additive Algorithm for the Realizable Case

Equipped with the simple unified notion of loss we describe in this section a single online algorithm that is applicable to all three problems. The algorithm and the analysis we present in this section assume that there exist a weight vector w ⋆ and an insensitivity parameter ǫ ⋆ for which the data is perfectly realizable. Namely, we assume that ℓ ǫ ⋆ (w ⋆ ; z t ) = 0 for all t which implies that, y t (w ⋆ · x t ) ≥ |ǫ ⋆ | (Class.) |y t − w ⋆ · x t | ≤ ǫ ⋆ (Reg.) x t − w ⋆ ≤ ǫ ⋆ (Unic.) . (4) A modification of the algorithm for the unrealizable case is given in Sec. 5. The general method we use for deriving our on-line update rule is to define the new weight vector w t+1 as the solution to the following projection problem w t+1 = argmin w 1 2 w − w t 2 s.t. ℓ ǫ (w; z t ) = 0 , (5) namely, w t+1 is set to be the projection of w t onto the set of all weight vectors that attain a loss of zero. We denote this set by C. For the case of classification, C is a half space, C = {w : −y t w · x t ≤ ǫ}. For regression C is an ǫ-hyper-slab, C = {w : |w · x t − y t | ≤ ǫ} and for uniclass it is a ball of radius ǫ centered at x t , C = {w : w − x t ≤ ǫ}. In Fig. 2 we illustrate the projection for the three cases. This optimization problem attempts to keep w t+1 as close to w t as possible, while forcing w t+1 to achieve a zero loss on the most recent example. The resulting algorithm is passive whenever the loss is zero, that is, w t+1 = w t whenever ℓ ǫ (w t ; z t ) = 0. In contrast, on rounds for which ℓ ǫ (w t ; z t ) > 0 we aggressively force w t+1 to satisfy the constraint ℓ ǫ (w t+1 ; z t ) = 0. Parameter: Insensitivity: ǫ Initialize: Set w 1 = 0 (R&C) ; w 1 = x 0 (U) For t = 1, 2, . . . • Get a new instance: z t ∈ R n • Suffer loss: ℓ ǫ (w t ; z t ) • If ℓ ǫ (w t ; z t ) > 0 : 1. Set v t (see Table 1) 2. Set τ t = ℓǫ(wt;zt) vt 2 3. Update: w t+1 = w t + τ t v t Figure 1: The additive PA algorithm. Therefore we name the algorithm passive-aggressive or PA for short. In the following we show that for the three problems described above the solution to the optimization problem in Eq. (5) yields the following update rule, w t+1 = w t + τ t v t , (6) where v t is minus the gradient of the discrepancy and τ t = ℓ ǫ (w t ; z t )/v t 2 . (Note that although the discrepancy might not be differentiable everywhere, its gradient exists whenever the loss is greater than zero). To see that the update from Eq. (6) is the solution to the problem defined by Eq. (5), first note that the equality constraint ℓ ǫ (w; z t ) = 0 is equivalent to the inequality constraint δ(w; z t ) ≤ ǫ. The Lagrangian of the optimization problem is L(w, τ ) = 1 2 w − w t 2 + τ (δ(w; z t ) − ǫ) , (7) w t w t+1 q w t w t+1 q w t w t+1 q Figure 2: An illustration of the update: w t+1 is found by projecting the current vector w t onto the set of vectors attaining a zero loss on z t . This set is a stripe in the case of regression, a half-space for classification, and a ball for uniclass. where τ ≥ 0 is a Lagrange multiplier. To find a saddle point of L we first differentiate L with respect to w and use the fact that v t is minus the gradient of the discrepancy to get, ∇ w (L) = w − w t + τ ∇ w δ = 0 ⇒ w = w t + τ v t . To find the value of τ we use the KKT conditions. Hence, whenever τ is positive (as in the case of non-zero loss), the inequality constraint, δ(w; z t ) ≤ ǫ, becomes an equality. Simple algebraic manipulations yield that the value τ for which δ(w; z t ) = ǫ for all three problems is equal to, τ t = ℓ ǫ (w; z t )/v t 2 . A summary of the discrepancy functions and their respective updates is given in Table 1. The pseudo-code of the additive algorithm for all three settings is given in Fig. 1. We now discuss the initialization of w 1 . For classification and regression a reasonable choice for w 1 is the zero vector. However, in the case of uniclass initializing w 1 to be the zero vector might incur large losses if, for instance, all the instances are located far away from the origin. A more sensible choice for uniclass is to initialize w 1 to be one of the examples. For simplicity of the description we assume that we are provided with an example x 0 prior to the run of the algorithm and initialize w 1 = x 0 . To conclude this section we note that for all three cases the weight vector w t is a linear combination of the instances. This representation enables us to employ kernels [15].

Analysis

The following theorem provides a unified loss bound for all three settings. After proving the theorem we discuss a few of its implications. Theorem 1 Let z 1 , z 2 , . . . , z t , . . . be a sequence of examples for one of the problems described in Table 1. Assume that there exist w ⋆ and ǫ ⋆ such that ℓ ǫ ⋆ (w ⋆ ; z t ) = 0 for all t. Then if the additive PA algorithm is run with ǫ ≥ ǫ ⋆ , the following bound holds

for

any T ≥ 1 T t=1 (ℓ ǫ (w t ; z t )) 2 + 2(ǫ − ǫ ⋆ ) T t=1 ℓ ǫ (w t ; z t ) ≤ B w ⋆ − w 1 2 , (8) where for classification and regression B is a bound on the squared norm of the instances (∀t : B ≥ x t 2 Proof: Define ∆ t = w t − w ⋆ 2 − w t+1 − w ⋆ 2 . We prove the theorem by bounding T t=1 ∆ t from above and below. First note that T t=1 ∆ t is a telescopic sum and therefore T t=1 ∆ t = w 1 − w ⋆ 2 − w T +1 − w ⋆ 2 ≤ w 1 − w ⋆ 2 . (9) This provides an upper bound on t ∆ t . In the following we prove the lower bound ∆ t ≥ ℓ ǫ (w t ; z t ) B (ℓ ǫ (w t ; z t ) + 2(ǫ − ǫ ⋆ )) . (10) First note that we do not modify w t if ℓ ǫ (w t ; z t ) = 0. Therefore, this inequality trivially holds when ℓ ǫ (w t ; z t ) = 0 and thus we can restrict ourselves to rounds on which the discrepancy is larger than ǫ, which implies that ℓ ǫ (w t ; z t ) = δ(w t ; z t ) − ǫ. Let t be such a round then by rewriting w t+1 as w t + τ t v t we get, ∆ t = w t − w ⋆ 2 − w t+1 − w ⋆ 2 = w t − w ⋆ 2 − w t + τ t v t − w ⋆ 2 = w t − w ⋆ 2 − τ 2 t v t 2 + 2τ t (v t · (w t − w ⋆ )) + w t − w ⋆ 2 = −τ 2 t v t 2 + 2τ t v t · (w ⋆ − w t ) . (11) Using the fact that −v t is the gradient of the convex function δ(w; z t ) at w t we have, δ(w ⋆ ; z t ) − δ(w t ; z t ) ≥ (−v t ) · (w ⋆ − w t ) . (12) Adding and subtracting ǫ from the left-hand side of Eq. (12) and rearranging we get, v t · (w ⋆ − w t ) ≥ δ(w t ; z t ) − ǫ + ǫ − δ(w ⋆ ; z t ) . (13) Recall that δ(w t ; z t ) − ǫ = ℓ ǫ (w t ; z t ) and that ǫ ⋆ ≥ δ(w ⋆ ; z t ). Therefore, (δ(w t ; z t ) − ǫ) + (ǫ − δ(w ⋆ ; z t )) ≥ ℓ ǫ (w t ; z t ) + (ǫ − ǫ ⋆ ) . t v t 2 + 2τ t (ℓ ǫ (w t ; z t ) + (ǫ − ǫ ⋆ )) = τ t −τ t v t 2 + 2ℓ ǫ (w t ; z t ) + 2(ǫ − ǫ ⋆ ) . (15) Plugging τ t = ℓ ǫ (w t ; z t )/v t 2 into Eq. (15) we get ∆ t ≥ ℓ ǫ (w t ; z t ) v t 2 (ℓ ǫ (w t ; z t ) + 2(ǫ − ǫ ⋆ )) . For uniclass v t 2 is always equal to 1 by construction and for classification and regression we have v t 2 = x t 2 ≤ B which gives, ∆ t ≥ ℓ ǫ (w t ; z t ) B (ℓ ǫ (w t ; z t ) + 2(ǫ − ǫ ⋆ )) . Comparing the above lower bound with the upper bound in Eq. (9) we get T t=1 (ℓ ǫ (w t ; z t )) 2 + T t=1 2(ǫ − ǫ ⋆ )ℓ ǫ (w t ; z t ) ≤ Bw ⋆ − w 1 2 . This concludes the proof. Let us now discuss the implications of Thm. 1. We first focus on the classification case. Due to the realizability assumption, there exist w ⋆ and ǫ ⋆ such that for all t, ℓ ǫ ⋆ (w ⋆ ; z t ) = 0 which implies that y t (w ⋆ · x t ) ≥ −ǫ ⋆ . Dividing w ⋆ by its norm we can rewrite the latter as y t ( ˆ w ⋆ · x t ) ≥ ˆ ǫ ⋆ wherê w ⋆ = w ⋆ /w ⋆ andˆǫ ⋆ = |ǫ ⋆ |/w ⋆ . The parameterˆǫ ⋆ is often referred to as the margin of a unit-norm separating hyperplane. Now, setting ǫ = −1 we get that ℓ ǫ (w; z) = [1 − y(w · x)] + – the hinge loss for classification. We now use Thm. 1 to obtain two loss bounds for the hinge loss in a classification setting. First, note that by also setting w ⋆ = ˆ w ⋆ /ˆ ǫ ⋆ and thus ǫ ⋆ = −1 we get that the second term on the left hand side of Eq. (8) vanishes as ǫ ⋆ = ǫ = −1 and thus, T t=1 ([1 − y t (w t · x t )] + ) 2 ≤ B w ⋆ 2 = B (ˆ ǫ ⋆ ) 2 . (17) We thus have obtained a bound on the squared hinge loss. The same bound was also derived by Herbster [8]. We can immediately use this bound to derive a mistake bound for the PA algorithm. Note that the algorithm makes a prediction mistake iff y t (w t · x t ) ≤ 0. In this case, [1 − y t (w t · x t )] + ≥ 1 and therefore the number of prediction mistakes is bounded by B/(ˆ ǫ ⋆ ) 2 . This bound is common to online algorithms for classification such as ROMMA [14]. We can also manipulate the result of Thm. 1 to obtain a direct bound on the hinge loss. Using again ǫ = −1 and omitting the first term in the left hand side of Eq. (8) we get, 2(−1 − ǫ ⋆ ) T t=1 [1 − y t (w t · x t )] + ≤ Bw ⋆ 2 . By setting w ⋆ = 2 ˆ w ⋆ /ˆ ǫ ⋆ , which implies that ǫ ⋆ = −2, we can further simplify the above to get a bound on the cumulative hinge loss, T t=1 [1 − y t (w t · x t )] + ≤ 2 B (ˆ ǫ ⋆ ) 2 . To conclude this section, we would like to point out that the PA online algorithm can also be used as a building block for a batch algorithm. Concretely, let S = {z 1 , . . . , z m } be a fixed training set and let β ∈ R be a small positive number. We start with an initial weight vector w 1 and then invoke the PA algorithm as follows. We choose an example z ∈ S such that ℓ ǫ (w 1 ; z) 2 > β and present z to the PA algorithm. We repeat this process and obtain w 2 , w 3 , . . . until the T 'th iteration on which for all z ∈ S, ℓ ǫ (w T ; z) 2 ≤ β. The output of the batch algorithm is w T . Due to the bound of Thm. 1, T is at most ⌈Bw ⋆ −w 1 2 /β⌉ and by construction the loss of w T on any z ∈ S is at most √ β. Moreover, in the following lemma we show that the norm of w T cannot be too large. Since w T achieves a small empirical loss and its norm is small, it can be shown using classical techniques (cf. [15]) that the loss of w T on unseen data is small as well. Lemma 2 Under the same conditions of Thm. 1, the following bound holds for any T ≥ 1 w T − w 1 ≤ 2 w ⋆ − w 1 . Proof: First note that the inequality trivially holds for T = 1 and thus we focus on the case T > 1. We use the definition of ∆ t from the proof of Thm. 1. Eq. (10) implies that ∆ t is non-negative for all t. Therefore, we get from Eq. (9) that 0 ≤ T −1 t=1 ∆ t = w 1 − w ⋆ 2 − w T − w ⋆ 2 . (18) Rearranging the terms in Eq. (18) we get that w T − w ⋆ ≤ w ⋆ − w 1 . Finally, we use the triangle inequality to get the bound, w T − w 1 = (w T − w ⋆ ) + (w ⋆ − w 1 ) ≤ w T − w ⋆ + w ⋆ − w 1 ≤ 2 w ⋆ − w 1 . This concludes the proof. We now briefly describe an algorithm for the unrealizable case. This algorithm applies only to regression and classification problems. The case of uniclass is more involved and will be discussed in detail elsewhere. The algorithm employs two parameters. The first is the insensitivity parameter ǫ which defines the loss function as in the realizable case. However, in this case we do not assume that there exists w ⋆ that achieves zero loss over the sequence. We instead measure the loss of the online algorithm relative to the loss of any vector w ⋆ . The second parameter, γ > 0, is a relaxation parameter. Before describing the effect of this parameter we define the update step for the unrealizable case. As in the realizable case, the algorithm is conservative. That is, if the loss on example z t is zero then w t+1 = w t . In case the loss is positive the update rule is w t+1 = w t + τ t v t where v t is the same as in the realizable case. However, the scaling factor τ t is modified and is set to, τ t = ℓ ǫ (w t ; z t ) v t 2 + γ . The following theorem provides a loss bound for the online algorithm relative to the loss of any fixed weight vector w ⋆ . Theorem 3 Let z 1 = (x 1 , y 1 ), z 2 = (x 2 , y 2 ), . . . , z t = (x t , y t ), . . .

be a sequence of classification or regression examples. Let

w ⋆ be any vector in R n . Then if the PA algorithm for the unrealizable case is run with ǫ, and with γ > 0, the following bound holds for any T ≥ 1 and a constant B satisfying B ≥ x t 2 , T t=1 (ℓ ǫ (w t ; z t )) 2 ≤ (γ + B) w ⋆ − w 1 2 + 1 + B γ T t=1 (ℓ ǫ (w ⋆ ; z t )) 2 . (19) The proof of the theorem is based on a reduction to the realizable case (cf. [4, 13, 14]) and is omitted due to the lack of space.

Extensions

There are numerous potential extensions to our approach. For instance, if all the components of the instances are non-negative we can derive a multiplicative version of the PA algorithm. The multiplicative PA algorithm maintains a weight vector w t ∈ P n where P n = {x : x ∈ R n + , n j=1 x j = 1}. The multiplicative update of w t is, w t+1,j = (1/Z t ) w t,j e τtvt,j , where v t is the same as the one used in the additive algorithm (Table 1), τ t now becomes 4ℓ ǫ (w t ; z t )/v t 2 ∞ for regression and classification and ℓ ǫ (w t ; z t )/(8v t

∞

) for uniclass and Z t = n j=1 w t,j e τtvt,j is a normalization factor. For the multiplicative PA we can prove the following loss bound. Theorem 4 Let z 1 , z 2 , . . . , z t = (x t , y t ), . . . be a sequence of examples such that x t,j ≥ 0 for all t. Let D RE (ww ′ ) = j w j log(w j /w ′ j ) denote the relative entropy between w and w ′ . Assume that there exist w ⋆ and ǫ ⋆ such that ℓ ǫ ⋆ (w ⋆ ; z t ) = 0 for all t. where for classification and regression B is a bound on the square of the infinity norm of the instances (∀t : B ≥ x t 2 ∞ ) and B = 16 for uniclass. The proof of the theorem is rather technical and uses the proof technique of Thm. 1 in conjunction with inequalities on the logarithm of Z t (see for instance [7, 11, 9]). An interesting question is whether the unified view of classification, regression, and uniclass can be exported and used with other algorithms for classification such as ROMMA [14] and ALMA [5]. Another, rather general direction for possible extension surfaces when replacing the Euclidean distance between w t+1 and w t with other distances and divergences such as the Bregman divergence. The resulting optimization problem may be solved via Bregman projections. In this case it might be possible to derive general loss bounds, see for example [12]. We are currently exploring generalizations of our framework to other decision tasks such as distance-learning [16] and online convex programming [17].