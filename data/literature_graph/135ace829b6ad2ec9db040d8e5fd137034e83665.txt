Title: Semi-Markov Conditional Random Fields for Information Extraction

Abstract: We describe semi-Markov conditional random fields (semi-CRFs), a conditionally trained version of semi-Markov chains. Intuitively, a semi-CRF on an input sequence x outputs a " segmentation " of x, in which labels are assigned to segments (i.e., subsequences) of x rather than to individual elements x i of x. Importantly, features for semi-CRFs can measure properties of segments, and transitions within a segment can be non-Markovian. In spite of this additional power, exact learning and inference algorithms for semi-CRFs are polynomial-time—often only a small constant factor slower than conventional CRFs. In experiments on five named entity recognition problems, semi-CRFs generally outper-form conventional CRFs.

Content: CRFs and Semi-CRFs 2.1 Definitions

A CRF models Pr(y|x) using a Markov random field, with nodes corresponding to elements of the structured object y, and potential functions that are conditional on (features of) x. Learning is performed by setting parameters to maximize the likelihood of a set of (x, y) pairs given as training data. One common use of CRFs is for sequential learning problems like NP chunking [16], POS tagging [12], and NER [15]. For these problems the Markov field is a chain, and y is a linear sequence of labels from a fixed set Y. For instance , in the NER application, x might be a sequence of words, and y might be a sequence in {I, O} |x| , where y i = I indicates " word x i is inside a name " and y i = O indicates the opposite. Assume a vector f of local feature functions f = f 1 , . . . , f K , each of which maps a pair (x, y) and an index i to a measurement f k (i, x, y) ∈ R. Let f (i, x, y) be the vector of these measurements, and let F(x, y) = |x| i f (i, x, y). For example, in NER, the components of f might include the measurement f 13 (i, x, y) = [[x i is capitalized]] · [[y i = I]], where the indicator function [[c]] = 1 if c if true and zero otherwise; this implies that F 13 (x, y) would be the number of capitalized words x i paired with the label I. Following previous work [12] [16] we will define a conditional random field (CRF) to be an estimator of the form Pr(y|x, W) = 1 Z(x) e W·F(x,y) (1) where W is a weight vector over the components of F, and Z(x) = y e W·F(x,y ) . To extend this to the semi-Markov case, let s = s 1 , . . . , s p denote a segmentation of x, where segment s j = t j , u j , y j consists of a start position t j , an end position u j , and a label y j ∈ Y . Conceptually, a segment means that the tag y j is given to all x i 's between i = t j and i = u j , inclusive. We assume segments have positive length, and completely cover the sequence 1 . . . |x| without overlapping: that is, that t j and u j always satisfy t 1 = 1, u p = |x|, 1 ≤ t j ≤ u j ≤ |x|, and t j+1 = u j + 1. For NER, a valid segmentation of the sentence " I went skiing with Fernando Pereira in British Columbia " might be s = (1, 1, O), (2, 2, O), (3, 3, O), (4, 4, O), (5, 6, I), (7, 7, O), (8, 9, I), corresponding to the label sequence y = O, O, O, O, I, I, O, I, I. We now assume a vector g of segment feature functions g = g 1 , . . . , g K , each of which maps a triple (j, x, s) to a measurement g k (j, x, s) ∈ R, and define G(x, s) = |s| j g(j, x, s). We also make a restriction on the features, analogous to the usual Markovian assumption made in CRFs, and assume that every component g k of g is a function only of x, s j , and the label y j−1 associated with the preceding segment s j−1 . In other words, we assume that every g k (j, x, s) can be rewritten as g k (j, x, s) = g k (y j , y j−1 , x, t j , u j ) (2) for an appropriately defined g k . In the rest of the paper, we will drop the g notation and use g for both versions of the segment-level feature functions. A semi-CRF is then an estimator of the form Pr(s|x, W) = 1 Z(x) e W·G(x,s) (3) where again W is a weight vector for G and Z( x) = s e W·G(x,s ) .

An efficient inference algorithm

The inference problem for a semi-CRF is defined as follows: given W and x, find the best segmentation, argmax s Pr(s|x, W), where Pr(s|x, W) is defined by Equation 3. An efficient inference algorithm is suggested by Equation 2, which implies that argmax s Pr(s|x, W) = argmax s W · G(x, s) = argmax s W · j g(y j , y j−1 , x, t j , u j ) Let L be an upper bound on segment length. Let s i:y denote the set of all partial segmentations starting from 1 (the first index of the sequence) to i, such that the last segment has the label y and ending position i. Let V x,g,W (i, y) denote the largest value of W · G(x, s ) for any s ∈ s i:y . Omitting the subscripts, the following recursive calculation implements a semi-Markov analog of the usual Viterbi algorithm: V (i, y) = max y ,d=1...L V (i − d, y ) + W · g(y, y , x, i − d + 1, i) if i > 0 0 if i = 0 −∞ if i < 0 (4) The best segmentation then corresponds to the path traced by max y V (|x|, y).

Semi-Markov CRFs vs order-L CRFs

Since conventional CRFs need not maximize over possible segment lengths d, inference for semi-CRFs is more expensive. However, Equation 4 shows that the additional cost is only linear in L. For NER, a reasonable value of L might be four or five. 1 Since in the worst case L ≤ |x|, the semi-Markov Viterbi algorithm is always polynomial, even when L is unbounded. For fixed L, it can be shown that semi-CRFs are no more expressive than order-L CRFs. For order-L CRFs, however the additional computational cost is exponential in L. The difference is that semi-CRFs only consider sequences in which the same label is assigned to all L positions, rather than all |Y| L length-L sequences. This is a useful restriction, as it leads to faster inference. Semi-CRFs are also a natural restriction, as it is often convenient to express features in terms of segments. As an example, let d j denote the length of a segment, and let µ be the average length of all segments with label I. Now consider the segment feature g k1 (j, x, s) = (d j − µ) 2 · [[y j = I]]. After training, the contribution of this feature toward Pr(s|x) associated with a length-d entity will be proportional to e w k ·(d−µ) 2 —i.e., it allows the learner to model a Gaussian distribution of entity lengths. An exponential model for lengths could be implemented with the feature g k2 (j, x, y) = d j · [[y j = I]]. In contrast to the Gaussian-length feature above, g k2 is " equivalent to " a local feature function f (i, x, y) = [[y i = I]], in the following sense: for every triple x, y, s, where y is the tags for s, j g k2 (j, x, s) = i f (i, s, y). Thus a semi-CRF model based on the single feature g k2 could also be represented by a conventional CRF. In general, a semi-CRF model can be factorized in terms of an equivalent order-1 CRF model if and only if the sum of the segment features can be rewritten as a sum of local features. Thus the degree to which semi-CRFs are non-Markovian depends on the feature set.

Learning algorithm

During training the goal is to maximize log-likelihood over a given training set T = {(x , s )} N =1 . Following the notation of Sha and Pereira [16], we express the loglikelihood over the training sequences as L(W) = log Pr(s |x , W) = (W · G(x , s ) − log Z W (x )) (5) We wish to find a W that maximizes L(W). Equation 5 is convex, and can thus be maximized by gradient ascent, or one of many related methods. (In our implementation we use a limited-memory quasi-Newton method [13] [14].) The gradient of L(W) is the following: ∇L(W) = G(x , s ) − s G(s , x )e W·G(x ,s ) Z W (x ) (6) = G(x , s ) − E Pr(s |W) G(x , s ) (7) The first set of terms are easy to compute. However, to compute the the normalizer , Z W (x ), and the expected value of the features under the current weight vector, E Pr(s |W) G(x , s ), we must use the Markov property of G to construct a dynamic programming algorithm, similar for forward-backward. We thus define α(i, y) as the value of s ∈si:y e W·G(s ,x) where again s i:y denotes all segmentations from 1 to i ending at i and labeled y. For i > 0, this can be expressed recursively as α(i, y) = L d=1 y ∈Y α(i − d, y )e W·g(y,y ,x,i−d+1,i) with the base cases defined as α(0, y) = 1 and α(i, y) = 0 for i < 0. The value of Z W (x) can then be written as Z W (x) = y α(|x|, y). A similar approach can be used to compute the expectation s G(x , s )e W·G(x ,s ) . For the k-th component of G, let η k (i, y) be the value of the sum s ∈si:y G k (s , x )e W·G(x ,s ) , restricted to the part of the segmentation ending at position i. The following recursion 2 can then be used to compute η k (i, y): η k (i, y) = L d=1 y ∈Y (η k (i−d, y ) + α(i−d, y )g k (y, y , x, i−d + 1, i))e W·g(y,y ,x,i−d+1,i) Finally we let E Pr(s |W) G k (s , x) = 1 Z W (x) y η k (|x|, y ).

Experiments with NER data 3.1 Baseline algorithms and datasets

In our experiments, we trained semi-CRFs to mark entity segments with the label I, and put non-entity words into unit-length segments with label O. We compared this with two versions of CRFs. The first version, which we call CRF/1, labels words inside and outside entities with I and O, respectively. The second version, called CRF/4, replaces the I tag with four tags B, E, C, and U , which depend on where the word appears in an entity [2]. We compared the algorithms on five NER problems, associated with three different corpora. The Address corpus contains 4,226 words, and consists of 395 home addresses of students in a major university in India [1]. We considered extraction of city names and state names from this corpus. The Jobs corpus contains 73,330 words, and consists of 300 computerrelated job postings [4]. We considered extraction of company names and job titles. The 18,121-word Email corpus contains 216 email messages taken from the CSPACE email corpus [10], which is mail associated with a 14-week, 277-person management game. Here we considered extraction of person names.

Features

As features for CRF, we used indicators for specific words at location i, or locations within three words of i. Following previous NER work [7] ), we also used indicators for capitalization/letter patterns (such as " Aa+ " for a capitalized word, or " D " for a single-digit number). As features for semi-CRFs, we used the same set of word-level features, as well their logical extensions to segments. Specifically, we used indicators for the phrase inside a segment and the capitalization pattern inside a segment, as well as indicators for words and capitalization patterns in 3-word windows before and after the segment. We also used indicators for each segment length (d = 1, . . . , L), and combined all word-level features with indicators for the beginning and end of a segment. To exploit more of the power of semi-CRFs, we also implemented a number of dictionaryderived features, each of which was based on different dictionary D and similarity function sim. Letting x sj denote the subsequence x tj . . . x uj , a dictionary feature is defined as g D,sim (j, x, s) = argmax u∈D sim(x sj , u)—i.e., the distance from the word sequence x sj to the closest element in D. For each of the extraction problems, we assembled one external dictionary of strings, which were similar (but not identical) to the entity names in the documents. For instance, for city names in the Address data, we used a web page listing cities in India. Due to variations in the way entity names are written, rote matching these dictionaries to the data gives relatively low F1 values, ranging from 22% (for the job-title extraction task) to 57% (for the person-name task). We used three different similarity metrics (Jaccard, TFIDF, and JaroWinkler) which are known to work well for name-matching in data integration tasks [5]. All of the distance metrics are non-Markovian—i.e., the distance-based segment features cannot be decomposed into sums of local features. More detail on the distance metrics, feature sets, and datasets above can be found elsewhere [6]. We also extended the semi-CRF algorithm to construct, on the fly, an internal segment dictionary of segments labeled as entities in the training data. To make measurements on training data similar to those on test data, when finding the closest neighbor of x sj in the internal dictionary, we excluded all strings formed from x, thus excluding matches of x sj to itself (or subsequences of itself). This feature could be viewed as a sort of nearest-neighbor classifier; in this interpretation the semi-CRF is performing a sort of bi-level stacking [21]. For completeness in the experiments, we also evaluated local versions of the dictionary features. Specifically, we constructed dictionary features of the form f D,sim (i, x, y) = argmax u∈D sim(x i , u), where D is either the external dictionary used above, or an internal word dictionary formed from all words contained in entities. As before, words in x were excluded in finding near neighbors to x i .

Results and Discussion

We evaluated F1-measure performance 3 of CRF/1, CRF/4, and semi-CRFs, with and without internal and external dictionaries. A detailed tabulation of the results are shown in Table 1, and Figure 1 shows F1 values plotted against training set size for a subset of three of the tasks, and four of the learning methods. In each experiment performance was averaged over seven runs, and evaluation was performed on a hold-out set of 30% of the documents. In the table the learners are trained with 10% of the available data—as the curves show, performance differences are often smaller with more training data. Gaussian priors were used for all algorithms, and for semi-CRFs, a fixed value of L was chosen for each dataset based on observed entity lengths. This ranged between 4 and 6 for the different datasets. In the baseline configuration in which no dictionary features are used, semi-CRFs perform 0 10 20 30 40 50 60 70 80 90 100 0.05 0.1 0.15 0.2 0.25 0.3 0.35 0.4 0.45 0.5

F1 span accuracy

Fraction of available training data Address_State CRF/4 SemiCRF+int CRF/4+dict SemiCRF+int+dict 65 70 75 80 85 90 0.05 0.1 0.15 0.2 0.25 0.3 0.35 0.4 0.45 0.5

F1 span accuracy

Fraction of available training data Address_City CRF/4 SemiCRF+int CRF/4+dict SemiCRF+int+dict 65 70 75 80 85 90 0.05 0.1 0.15 0.2 0.25 0.3 0.35 0.4 0.45 0.5

F1 span accuracy

Fraction of available training data Email_Person CRF/4 SemiCRF+int CRF/4+dict SemiCRF+int+dict Figure 1: F1 as a function of training set size. Algorithms marked with " +dict " include external dictionary features, and algorithms marked with " +int " include internal dictionary features. We do not use internal dictionary features for CRF/4 since they lead to reduced accuracy. baseline +internal dict +external dict +both dictionaries F1 F1 ∆base F1 ∆base F1 ∆base ∆extern CRF/1 state 20.8 44.5 113.9 69.2 232.7 55.2 165.4 -67.3 title 28.5 3.8 -86.7 38.6 35.4 19.9 -30.2 -65.6 person 67.6 48.0 -29.0 81.4 20.4 64.7 -4.3 -24.7 city 70.3 60.0 -14.7 80.4 14.4 69.8 -0.7 -15.1 company 51.4 16.5 -67.9 55.3 7.6 15.6 -69.6 -77.2 CRF/4 state 15.0 25.4 69.3 46.8 212.0 43.1 187.3 -24.7 title 23.7 7.9 -66.7 36.4 53.6 14.6 -38.4 -92.0 person 70.9 64.5 -9.0 82.5 16.4 74.8 5.5 -10.9 city 73.2 70.6 -3.6 80.8 10.4 76.3 4.2 -6.1 company 54.8 20.6 -62.4 61.2 11.7 25.1 -54.2 -65.9 semi-CRF state 25.6 35.5 38.7 62.7 144.9 65.2 154.7 9.8 title 33.8 37.5 10.9 41.1 21.5 40.2 18.9 -2.5 person 72.2 74.8 3.6 82.8 14.7 83.7 15.9 1.2 city 75.9 75.3 -0. 8 84.0 10.7 83.6 10.1 -0.5 company 60.2 59.7 -0.8 60.9 1.2 60.9 1.2 0.0 Table 1: Comparing various methods on five IE tasks, with and without dictionary features. The column ∆base is percentage change in F1 values relative to the baseline. The column ∆extern is is change relative to using only external-dictionary features. best on all five of the tasks. When internal dictionary features are used, the performance of semi-CRFs is often improved, and never degraded by more than 2.5%. However, the less-natural local version of these features often leads to substantial performance losses for CRF/1 and CRF/4. Semi-CRFs perform best on nine of the ten task variants for which internal dictionaries were used. The external-dictionary features are helpful to all the algorithms . Semi-CRFs performs best on three of five tasks in which only external dictionaries were used. Overall, semi-CRF performs quite well. If we consider the tasks with and without external dictionary features as separate " conditions " , then semi-CRFs using all available informa- tion 4 outperform both CRF variants on eight of ten " conditions " . We also compared semi-CRF to order-L CRFs, with various values of L. 5 In Table 2 we show the result for L = 1, L = 2, and L = 3, compared to semi-CRF. For these tasks, the performance of CRF/4 and CRF/1 does not seem to improve much by simply increasing Table 2: F1 values for different order CRFs order.

Related work

Semi-CRFs are similar to nested HMMs [1], which can also be trained discriminitively [17]. The primary difference is that the " inner model " for semi-CRFs is of short, uniformly-labeled segments with non-Markovian properties, while nested HMMs allow longer, diversely-labeled, Markovian " segments " . Discriminative learning methods can be used for conditional random fields with architectures more complex than chains (e.g., [20, 18]), and one of these methods has also been applied to NER [3]. Further, by creating a random variable for each possible segment, one can learn models strictly more expressive than the semi-Markov models described here. However, for these methods, inference is not tractable, and hence approximations must be made in training and classification. An interesting question for future research is whether the tractible extension to CRF inference considered here can can be used to improve inference methods for more expressive models. In recent prior work [6], we investigated semi-Markov learning methods for NER based on a voted perceptron training algorithm [7]. The voted perceptron has some advantages in ease of implementation, and efficiency. (In particular, the voted perceptron algorithm is more stable numerically, as it does not need to compute a partition function. ) However , semi-CRFs perform somewhat better, on average, than our perceptron-based learning algorithm. Probabilistically-grounded approaches like CRFs also are preferable to marginbased approaches like the voted perceptron in certain settings, e.g., when it is necessary to estimate confidences in a classification.

Concluding

Remarks Semi-CRFs are a tractible extension of CRFs that offer much of the power of higher-order models without the associated computational cost. A major advantage of semi-CRFs is that they allow features which measure properties of segments, rather than individual elements. For applications like NER and gene-finding [11] , these features can be quite natural.

Appendix

An implementation of semi-CRFs is available at http://crf.sourceforge.net, and a NER package using this package is available on http://minorthird.sourceforge.net.