Title: Transliteration by Sequence Labeling with Lattice Encodings and Reranking

Abstract: We consider the task of generating transliter-ated word forms. To allow for a wide range of interacting features, we use a conditional random field (CRF) sequence labeling model. We then present two innovations: a training objective that optimizes toward any of a set of possible correct labels (since more than one translit-eration is often possible for a particular input), and a k-best reranking stage to incorporate nonlocal features. This paper presents results on the Arabic-English transliteration task of the NEWS 2012 workshop.

Content: Introduction

Transliteration is the transformation of a piece of text from one language's writing system into another . Since the transformation is mostly explained as local substitutions, deletions, and insertions, we treat word transliteration as a sequence labeling problem (Ganesh et al., 2008; Reddy and Waxmonsky , 2009), using linear-chain conditional random fields as our model (Lafferty et al., 2001; Sha and Pereira, 2003). We tailor this model to the transliteration task in several ways. First, for the Arabic-English task, each Arabic input is paired with multiple valid English transliteration outputs, any of which is judged to be correct. To effectively exploit these multiple references during learning, we use a training objective in which the model may favor some correct transliterations over the others. Computationally efficient inference is achieved by encoding the references in a lattice. Second, inference for our first-order sequence labeling model requires a runtime that is quadratic in the number of labels. Since our labels are character n-grams in the target language, we must cope with thousands of labels. To make the most of each inference call during training, we apply a mini-batch training algorithm which converges quickly. Finally, we wish to consider some global features that would render exact inference intractable. We therefore use a reranking model (Collins, 2000). We demonstrate the performance benefits of these modifications on the Arabic-English transliteration task, using the open-source library cdec (Dyer et al., 2010) 1 for learning and prediction.

Problem Description

In the NEWS 2012 workshop, the task is to generate a list of ten transliterations in a specified target language for each named entity (in a known source language) in the test set. A training set is provided for each language pair. An entry in the training set comprises a named entity in the source language and one or more transliterations in the target language. Zhang et al. (2012) provides a detailed description of the shared task. 3 Approach

Character Alignment

In order to extract source-target character mappings , we use m2m-aligner (Jiampojamarn et al., 2007), 2 which implements a forward-backward algorithm to sum over probabilities of possible character sequence mappings, and uses Expectation Maximization to learn mapping probabilities. We allow source characters to be deleted, but not target characters . Parameters -maxX and -maxY are tuned on a devevelopment set. Our running example is the Arabic name EAdl (in Buckwalter's ASCII-based encoding of Arabic) with two English transliterations: ADEL and 'ADIL. The character alignment for the two pairs is shown in Fig. 1. A D E L E A d l ‫ﻉ‬ ‫ﺍ‬ ‫ﺩ‬ ‫ﻝ‬ A D I L E A d l ‫ﻉ‬ ‫ﺍ‬ ‫ﺩ‬ ‫ﻝ‬ ' Arabic English Arabic English Figure 1: Character alignment for transliterating EAdl to ADEL and 'ADIL.

Sequence Labeling Scheme and Notation

We frame transliteration as a sequence labeling problem. However, transliteration is not a one-toone process, meaning that a na¨ıve application of one-label-per-token sequence models would be unlikely to perform well. Previous work has taken two different approaches. Reddy and Waxmonsky (2009) first segment the input character sequence, then use the segments to construct a transliteration in the target language. Since segmentation errors will compound to produce transliteration errors, we avoid this. Ganesh et al. (2008) do not require a segmentation step, but their model does not allow for many-to-one and many-to-many character mappings which are often necessary. Our approach overcomes both these shortcomings: we have neither an explicit segmentation step, nor do we forbid many-to-many mappings. In our model, each character x i in the source-language input x = x 1 , x 2 , . . . , x n is assigned a label y i . However, a label y i is a sequence of one or more target-language characters, a special marker indicating a deletion (), or a special marker indicating involvement in a many-to-one mapping (δ), that is, y i ∈ Σ + ∪ {, δ}, where Σ is the target language alphabet. 3 When an input x has multiple alternative reference transliterations, we denote the set Y * (x) = {y 1 , y 2 , . . . , y K }. We map the many-to-many alignments produced by m2m-aligner to one label for each input character , using the scheme in Table 1. Note that zeroto-one alignments are not allowed. The two reference label sequences for our running example, which are constructed from the alignments in Fig. 1 are: Type Alignment Labels 1:0 x i : y i = 1:1 x i : t j y i = t j 1:many x i : t j . . . t k y i = t j . . . t k many:1 x i . . . x p : t j y p = t j Of key importance in our model is defining, for each source character, the set of labels that can be considered for it. For each source character, we add all labels consistent with character alignments to the lexicon.

Model

Our model for mapping from inputs to outputs is a conditional random field (Lafferty et al., 2001), which defines the conditional probability of every possible sequence labeling y of a sequence x with the parametric form: p λ (y | x) ∝ exp |x| i=1 λ · f (x, y i , y i−1 ) (1) where f is a vector of real-valued feature functions.

Features

The feature functions used are instantiated by applying templates shown in Table 2 to each position i in the input string x.

Parameter

Learning Given a training dataset of pairs {{x j , y j } j=1 (note that each y is derived from the max-scoring character alignment), a CRF is trained to maximize the regularized conditional log-likelihood: max λ L {1,...,,} (λ) j=1 log p λ (y j | x j ) − C||λ|| 2 2 (2) The regularization strength hyperparameter is tuned on development data. On account of the large data sizes and large label sets in several language pairs

Feature Template

Description U1:y i -x i , U2:y i -x i−1 -x i , U3:y i -x i -x i+1 , moving window of unigram, U4:y i -x i−2 -x i−1 -x i , bigram and trigram context U5:y i -x i−1 -x i -x i+1 , U6:y i -x i -x i+1 -x i+2 U7:y i , B1:y i -y i−1 label unigrams and bigrams U8:|y i | label size (in characters) Table 2: Feature templates for features extracted from transliteration hypotheses. The SMALLCAPS prefixes prevent accidental feature collisions. ( Table 3), batch optimization with L-BFGS is infeasible . Therefore, we use a variant of the minibatch L-BFGS learning approach proposed by Le et al. (2011). This algorithm uses a series of randomly chosen mini-batches B (1) , B (2) , . . ., each a subset of {1, . . . , }, to produce a series of weights λ (1) , λ (2) , . . . by running N iterations of L-BFGS on each mini-batch to compute the following: max λ (i) L B (i) (λ (i) ) − T λ (i) − λ (i−1) 2 2 (3) The T parameter controls how far from the previous weights the optimizer can move in any particular mini-batch 4 . We use mini-batch sizes of 5, and start training with a small value of T and increase it as we process more iterations. This is equivalent to reducing the step-size with the number of iterations in conventional stochastic learning algorithms. Table 3: Size of the label set in some language pairs.

Using Multiple Reference Transliterations

In some language pairs, NEWS-2012 provides multiple reference transliterations in the training set. In this section, we discuss two possibilities for using these multiple references to train our transliteration ' A DI L DE A δ Figure 2: Lattice encoding two transliterations of EAdl: ADEL and 'ADIL. model. The first possibility is to create multiple independent training inputs for each input x, one for each correct transliteration in Y * (x). Using this approach , with K different transliterations, the CRF training objective will attempt to assign probability 1 K to each correct transliteration, and 0 to all others (modulo regularization). Alternatively, we can train the model to maximize the marginal probability assigned by the model to the set of correct labels Y * = {y 1 , . . . , y K }. That is, we assume a set of training data {(x j , Y * j )} j=1 and replace the standard CRF objective with the following (Dyer, 2009 ): 5 max λ j=1 log y∈Y * j p λ (y | x j ) − C||λ|| 2 2 (

4)

This learning objective has more flexibility. It can maximize the likelihood of the training data by giving uniform probability to each reference transliteration for a given x, but it does not have to. In effect, we do not care how probability mass is distributed among the correct labels. Our hope is that if some transliterations are difficult to model—perhaps because they are incorrect—the model will be able to disregard them. To calculate the marginal probability for each x j , we represent Y * (x) as a label lattice, which is supported as label reference format in cdec. A further computational advantage is that each x in the training data is now only a single training instance meaning that fewer forward-backward evaluations are necessary. The lattice encoding of both transliterations of our running example is shown in Fig. 2 .

Reranking

CRFs require feature functions to be " local " to cliques in the underlying graphical model. One way to incorporate global features is to first decode the k-best transliterations using the CRF, then rerank based on global features combined with the CRF's conditional probability of each candidate. We experiment with three non-local features: Character language model: an estimate of p charLM (y) according to a trigram character language model (LM). While a bigram LM can be factored into local features in a first order CRF, higher n-gram orders require a higher-order CRF. Class language model: an estimate of p classLM (y), similar to the character LM, but collapses characters which have a similar phonetic function into one class (vowels, consonants, and hyphens/spaces). Due to the reduced number of types in this model, we can train a 5-gram LM. Transliteration length: an estimate of p len (|y| | |x|) assuming a multinomial distribution with parameters estimated using transliteration pairs of the training set. The probabilistic model for each of the global features is trained using training data provided for the shared task. The reranking score is a linear combination of log p crf (y | x), log p charLM (y), log p classLM (y) and log p len (|y| | |x|). Linear coefficients are optimized using simulated annealing, optimizing accuracy of the 1-best transliteration in a development set. k-best lists are extracted from the CRF trellis using the lazy enumeration algorithm of Huang and Chiang (2005) .

Experiments

We tested on the NEWS 2012 Arabic-English dataset. The train, development, and test sets consist of 27,177, 1,292, and 1,296 source named entities , respectively, with an average 9.6 references per name in each case. Table 4 summarizes our results using the ACC score (Zhang et al., 2012) (i.e., word accuracy in top-1). " Basic CRF " is the model with mini-batch learning and represents multiple reference transliterations as independent training examples. We manually tuned the number of training examples and LBFGS iterations per mini-batch to five and eight, respectively. " CRF w/lattice " compactly represents the multiple references in a lattice, as detailed in §3.6. We consider reranking using each of the three global features along with the CRF, as well as the iterations, which is, approximately, seven times the number of iterations needed for convergence with lattice-encoded labels. A model converges when its ACC score on the development set ceases to improve in 800 mini-batch iterations. Results also show that reranking a k-best list of only five transliterations with any of the global features improves accuracy. Using all the features together to rerank the k-best list gives further improvements.

Conclusion

We built a CRF transliteration model that allows for many-to-many character mappings. We address limitations of CRFs using mini-batch learning and reranking techniques. We also show how to relax the learning objective when the training set contains multiple references, resulting in faster convergence and improved transliteration accuracy. We suspect that including features of higher-order n-gram labels would help improve transliteration accuracy further, but it makes inference intractable due to the large set of labels. In future work, coarse transformations of label n-grams might address this problem.